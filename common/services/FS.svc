service FS {

   /** NexusOS: Filesystem interface 
    
       ** Notice:

       In userspace, you should almost always prefer the posix IO interface
       over this.

       ** Design:

       All filesystems are implemented as IPC servers and can be contacted
       through this client interface. Most calls are standard and self-
       explanatory. 
    
       ** Interface: FS_[xxx] and nexusfs_[xxx]

       The main FS functionality is offered through the IDL generated FS_
       functions. The nexusfs_ offer a more convenient interface for 
       operations that are tedious to encode in FS_ notation. Not all
       FS_ functions need a nexusfs_ counterpart, however.

       ** Mounting

       To mount a filesystem, issue a nexusfs_mount(..) command and give the 
       port controlling that FS. If the parent argument is empty, this FS will
       be considered the root and FS_conn_handle (see below) will be updated
       accordingly. The mount operation will create a connection to the port 
       and store it in a lookup table. 
       
       ** Lookup

       By default, all FS_[xxx] commands are sent over the connection 
       FS_conn_handle to a fixed port, as a result of how the IDL generates 
       code. We set this handle to point to the root filesystem. For all
       other filesystems, you have to call the FS_[xxx]_ext functions,
       which take a port as extra command. 
     
       The nexusfs_ functions are automatically routed to the correct
       port; they learn the route by extracting the port number from the FSID
    */

  decls {
    includefiles { "u:<string.h>" }
    includefiles { "<nexus/commontypedefs.h>" }
    includefiles { "<nexus/fs.h>" }
    includefiles { "u:<nexus/ipc.h>" }
	
    /**** Support functions to simplify FS.svc calling ********/
 
    int nexusfs_mount(FSID target, FSID fs_root);
    int nexusfs_unmount(FSID target, FSID fs_root);
    FSID nexusfs_getroot(void);

    FSID nexusfs_mkdir(FSID parent, const char *name);
    FSID nexusfs_mk(FSID parent, const char *name, void *value);
    FSID nexusfs_mk_dev(FSID parent, const char *name, unsigned long port);
    FSID nexusfs_mk_bin(FSID parent, const char *name, void *value, int vlen);
    int  nexusfs_unlink(FSID parent, const char *name);
    int  nexusfs_rename(FSID node, FSID newparent, const char *newname);

    int nexusfs_pin(FSID node);
    int nexusfs_unpin(FSID node);
    int nexusfs_truncate(FSID node, int len);
    
    FSID nexusfs_lookup(FSID parent, const char *name);
    FSID nexusfs_lookup_resolvelink(FSID parent, const char *name);
  }

  decls __caller__ {
    includefiles { "<nexus/defs.h>",
	    	   "<nexus/hashtable.h>",
	    	   "u:<nexus/sema.h>",
	    	   "k:<nexus/synch.h>",
	    	   "k:<nexus/synch-inline.h>",
	    	   "k:<nexus/user_compat.h>",
    		   "<nexus/fs.h>" }
	
	/** The rootnode of the caller's namespace */
	static FSID FS_root;
	static struct HashTable *inode_cache;

	struct inode_key {
		FSID parent;
		char name[128];
		char do_resolve;
	};
    	
	/** Mount a volume.
	    Creates an IPC connection and stores that for later use. 
	 
	    @param target is the FSID of a valid directory, or FSID_EMPTY.
	           In the latter case, the filesystem is taken as the root
	           and FS_conn_handle is updated accordingly. 
	 
	    @param return 0 on success, an errorcode on failure. */
        int 
	nexusfs_mount(FSID parent, FSID child)
	{
	  // CHROOT
	  // If no parent, make this the new fs root node of the process.
	  // All FS_xxx calls, as generated by IDL, route to FS_conn_handle.
	  if (FSID_isNull(parent)) {
		FS_conn_handle = child.port;
		FS_root	= child;

#ifndef __NEXUSKERNEL__
		// tell higher layer IO to reset its namespace
		extern void posix_chroot(void);
		posix_chroot();
#endif
	  }
	  else {
		// Call Mount to have the parent FS create the link
		if (FS_Mount_ext(parent.port, parent, child)) {
		      return -FS_INVALID;
		}
	  }
	  	 
	  return 0;
	}
    
	FSID
	nexusfs_getroot(void)
	{
		return FS_root;
	}

	/** Reverse a mount operation. */
	int nexusfs_unmount(FSID parent, FSID child)
	{
	  // disassociate the volume with the parent directory
	  if (FSID_isDir(parent))
	 	 FS_Unmount_ext(parent.port, parent);
	  return 0;
	}

	int nexusfs_pin(FSID node)
	{
		return FS_Pin_ext(node.port, node);
	}

	int nexusfs_unpin(FSID node)
	{
		return FS_Unpin_ext(node.port, node, 0);
	}

	int nexusfs_truncate(FSID node, int len)
	{
		return FS_Truncate_ext(node.port, node, len);
	}

	/** Create a directory */
	FSID
	nexusfs_mkdir(FSID parent, const char *name)
	{
	  FSID ret = FS_Create_ext(parent.port, parent,
			       (struct VarLen) {.data= (char*) name, .len=strlen(name) + 1}, 
			       FS_NODE_DIR);
	  return ret;
	}

	/** Create a file and write its initial contents */
	FSID
	__nexusfs_mk_bin(FSID parent, const char *name, void *value, int vlen, int type)
	{
	  FSID file;
	  int nlen, ret;

	  nlen = strlen(name) + 1;
	  file = FS_Create_ext(parent.port, parent, 
			       (struct VarLen) {.data= (char*) name, .len=nlen}, type);
	  if (!FSID_isValid(file))
		  return file;
	  
	  if (vlen) {
		  ret = FS_Write_ext(parent.port, file, 0, 
				     (struct VarLen) {.data=value, .len=vlen}, vlen);
		  if (ret < vlen) // nb: semantics are stronger than posix:write(..)
			  return FSID_ERROR(ret);
	  }

	  return file;
	}

	FSID
	nexusfs_mk_bin(FSID parent, const char *name, void *value, int vlen)
	{
	  return __nexusfs_mk_bin(parent, name, value, vlen, FS_NODE_FILE);
	}

	FSID
	nexusfs_mk_dev(FSID parent, const char *name, unsigned long port)
	{
	  return __nexusfs_mk_bin(parent, name, (void *) &port, sizeof(port), FS_NODE_DEV);
	}

	/** Create a file and write its initial contents (\0 terminated) */
	FSID
	nexusfs_mk(FSID parent, const char *name, void *value)
	{
	  if (value)
	    return nexusfs_mk_bin(parent, name, value, strlen(value) + 1);
	  else
	    return nexusfs_mk_bin(parent, name, NULL, 0);
	}

	static FSID
	nexusfs_lookup_inner(FSID parent, const char *name, int do_resolve)
	{
// NB: quick hack on my last day in the lab: inode cache
//     corners cut: (1) fixed key length: overflow causes (undetected) collisions, 
//                  (2) limited testing,
//                  (3) no deallocation
//                  (4) no upper bound on cache size
	  FSID node;
#if 1 && !defined __NEXUSKERNEL__ && !defined NO_EXPERIMENTAL_INODE_CACHE
	  struct inode_key key;
	  FSID *node_cached;
	  int nlen;

	  if (!inode_cache)
		  inode_cache = hash_new(4096, sizeof(struct inode_key));

	  // create inode cache key
	  key.parent = parent;
	  nlen = strlen(name);
	  memset(key.name, 0, 128);
	  memcpy(key.name, name, nlen < 128 ? nlen : 128);
	  key.do_resolve = do_resolve;

	  // lookup in cache
	  node_cached = hash_findItem(inode_cache, &key);
	  if (node_cached)
		return *node_cached;

#endif
          node = FS_Lookup_ext(parent.port, parent, 
			       VARLENSTR(name), do_resolve);

#if 1 && !defined __NEXUSKERNEL__ && !defined NO_EXPERIMENTAL_INODE_CACHE
	  // add to cache
	  if (FSID_isValid(node)) {
		node_cached = nxcompat_alloc(sizeof(FSID));
		memcpy(node_cached, &node, sizeof(FSID));
		hash_insert(inode_cache, &key, node_cached);
	  }
#endif

	  return node;
	}

	/** Lookup operation */
	FSID
	nexusfs_lookup(FSID parent, const char *name)
	{
	  return nexusfs_lookup_inner(parent, name, 0);
	}

	/** Near duplicate of nexusfs_lookup: resolve mountpoints automatically
	    too lazy to change all its callers */
	FSID
	nexusfs_lookup_resolvelink(FSID parent, const char *name)
	{
	  return nexusfs_lookup_inner(parent, name, 1);
	}
    
	int 
	nexusfs_rename(FSID node, FSID newparent, const char *newname)
	{
	  return FS_Rename_ext(node.port, node, newparent,
			       (struct VarLen) {.data = (char *) newname, 
			       			.len = strlen(newname) + 1});
	}

	/** Combined unlink() and rmdir() implementation
	    @return 0 on success, errorcode <0 on failure */
	int
	nexusfs_unlink(FSID parent, const char *name)
	{
	  FSID child = nexusfs_lookup(parent, name);
	  if (!FSID_isValid(child))
		  return -1;
	  return FS_Unlink_ext(parent.port, parent, child);
	}

  }

  // The primary operations are:
  //  For files: read, write, truncate, sync, size, and unlink.
  //  For directories, readdir, create, lookup, mount, unmount, and unlink.
  //
  // Files and directories are referred to using FSIDs. These are opaque
  // handles, and may be re-used by servers over time. Care must be taken to
  // ensure that a file or directory's FSID, if held by some client, does not
  // get re-used for some other file or directory until the client is done with
  // the FSID. This is done by marking things as "busy".
  //
  // Pin and unpin are used to mark a file or directory as "busy".
  //
  // Any operation is permitted on a busy file. But, if a busy file is unlinked
  // it becomes an orphan. An orphaned file can still be manipulated just like
  // any other, although any operation on an orphan may result in FS_STALE, at
  // the discretion of the filesystem. As soon as an orphaned file becomes
  // non-busy, the file disappears and its FSID can be reclaimed for use by
  // other objects.
  //
  // Directories can only be unlinked if they are empty and not mounted. If a
  // directory is busy at the time unlinked is called, or has orphaned
  // sub-directories, either the unlink request is rejected with error
  // FS_BUSYDIR, or the directory itself becomes an orphan. An orphan cannot be
  // modified in any way, and may return FS_STALE for any operation. Once all of
  // the directories orphaned sub-directories finally disappear, and the
  // directory becomes non-busy itself, then the directory disappears and its
  // FSID can be reclaimed for use by other objects.
  //
  // Notice that if a filesystem uses sequentially increasing FSIDs, then both
  // Pin and Unpin can be no-ops, and there is no need to keep track of orphans
  // or the "busy" state of files or directories. Instead, any operation on a
  // seemingly invalid file handle fails with FS_INVALID if the FSID was never
  // yet used, or FS_STALE if the FSID was used at some point in the past. This
  // is the strategy used by both Reflection and kernelfs.
  //
  // Directories can only be mounted if they are non-busy. Not all filesystems
  // support Mount/Unmount.
  //
  // As a general rule, an FSID can only be stored long-term in an application
  // if the FSID is pinned, or is known to be a non-empty directory. Otherwise,
  // the FSID can become invalid without warning, or worse, suddenly be reused
  // for newly created object.
  //
  // Normally, applications pin files and directories that are currently "open",
  // as well as the (leaf node of the) current working directory. The parent
  // directories from the current working directory or from an open directory
  // need not be pinned, because they are non-empty and so will not be unlinked.
  // The directory and parents for an open file need not be pinned, because the
  // path will not be used again.
  //
  // Mounted directories introduces some complications. Lookup normally resolves
  // mounts, and returns the (presumably root node) of the mounted file system.
  // A stale FSID to the original, non-resolved FSID will still work as usual,
  // however.  Thus Pin, Create, ReadDir, and Lookup all work on a mounted
  // directory just as if the directory were not mounted at all. Normally, an
  // application would prefer to use the resolved directory instead, but it is
  // not always possible to efficiently detect a stale directory FSID.
  
  interface lf_generate { (0); } lf_check { 1; }
  int Pin(FSID target_node) {
    return 0;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Unpin(FSID target_node, int do_sync) {
    return 0;
  }

  interface lf_generate { (0); } lf_check { 1; }
  FSID Create(FSID parent_node, 
	    __input__ struct VarLen node_name, int nodeType) {
    return FSID_ERROR(FS_UNSUPPORTED);
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Read(FSID target_node, int file_position, 
	    __output__ struct VarLen dest, int count) {
    return -FS_UNSUPPORTED;
  }

  /** Read the name of an item in a directory. 
   
      @param offset selects the number of the item to read.
      @return 1 if there are more items, 0 if not or an negative errorcode on failure
   
      Note that this implementation may skip/repeat files if the
      directory is changed in between readdir calls. This behavior
      is accepted by the Posix/SUS standards. */
  interface lf_generate { (0); } lf_check { 1; }
  int 
  ReadDir(FSID target_node, __output__ struct VarLen dest, int offset) {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Write(FSID target_node, int file_position,
	     __input__ struct VarLen source, int count) {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Truncate(FSID target_node, int target_len) {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Sync(FSID target_node) {
    return -FS_UNSUPPORTED;
  }

  // should be generalized to stat() eventually
  interface lf_generate { (0); } lf_check { 1; }
  int Size(FSID target_node) {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  FSID Lookup(FSID parent_node, __input__ struct VarLen node_name, int resolve_mounts) {
    return FSID_ERROR(FS_UNSUPPORTED);
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Rename(FSID node, FSID newparent, 
	     __input__ struct VarLen new_name)
  {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Unlink(FSID parent_node, FSID child_node) {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Mount(FSID target_node, FSID mount_node) {
    return -FS_UNSUPPORTED;
  }

  interface lf_generate { (0); } lf_check { 1; }
  int Unmount(FSID target_node) {
    return -FS_UNSUPPORTED;
  }

  /** Create a hard link */
  interface lf_generate { (0); } lf_check { 1; }
  FSID Link(FSID target_dir, FSID source_node) {
    return FSID_ERROR(FS_UNSUPPORTED);
  }
}
