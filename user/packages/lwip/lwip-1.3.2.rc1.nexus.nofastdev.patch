diff -Nur lwip-1.3.2.rc1-unix//Makefile lwip-1.3.2.rc1/Makefile
--- lwip-1.3.2.rc1-unix//Makefile	1969-12-31 19:00:00.000000000 -0500
+++ lwip-1.3.2.rc1/Makefile	2010-12-22 15:04:46.250503999 -0500
@@ -0,0 +1,69 @@
+# lwip Makefile for Nexus
+#
+# this is mainly a unix port, but we replace system headers with 
+# our crosscompiled uclibc
+
+.PHONY: all clean distclean
+
+CC		:= gcc
+GCC_MAJOR       := $(shell gcc -dumpversion | cut -d'.' -f1)
+GCC_MINOR       := $(shell gcc -dumpversion | cut -d'.' -f2)
+GCC_HOME	:= /usr/lib/gcc/$(shell gcc -dumpmachine)/$(shell gcc -dumpversion)
+USER_HOME	:= ../../..
+CFLAGS		:= -O2 -Wall -fno-stack-protector
+LDFLAGS		:= -r -static -nostdlib
+
+INCS		:= -nostdinc -I ./src/include \
+		   -I $(USER_HOME)/../common/include \
+		   -I $(USER_HOME)/include \
+		   -isystem $(GCC_HOME)/include \
+		   -isystem $(GCC_HOME)/include-fixed
+
+OBJS := src/api/api_lib.o \
+		src/api/api_msg.o \
+		src/api/err.o \
+		src/api/netbuf.o \
+		src/api/netifapi.o \
+		src/api/sockets.o \
+		src/api/tcpip.o \
+		src/arch/sys_arch.o \
+		src/core/dhcp.o \
+		src/core/dns.o \
+		src/core/init.o \
+		src/core/mem.o \
+		src/core/memp.o \
+		src/core/netif.o \
+		src/core/pbuf.o \
+		src/core/raw.o \
+		src/core/sys.o \
+		src/core/stats.o \
+		src/core/udp.o \
+		src/core/tcp.o \
+		src/core/tcp_in.o \
+		src/core/tcp_out.o \
+		src/core/ipv4/autoip.o \
+		src/core/ipv4/icmp.o \
+		src/core/ipv4/igmp.o \
+		src/core/ipv4/inet.o \
+		src/core/ipv4/inet_chksum.o \
+		src/core/ipv4/ip.o \
+		src/core/ipv4/ip_addr.o \
+		src/core/ipv4/ip_frag.o \
+		src/netif/nexusif.o \
+		src/netif/etharp.o \
+		src/netif/loopif.o
+
+%.o: %.c 
+	$(CC) -c -o $@ $(CFLAGS) $(INCS) $+ 
+
+all: liblwip.a
+
+liblwip.a: $(OBJS)
+	$(LD) $(LDFLAGS) -o $@ $+
+
+clean:
+	@-rm -f `find . -name *.o`
+
+distclean: clean
+	@-rm liblwip.a
+
diff -Nur lwip-1.3.2.rc1-unix//src/api/netdb.c lwip-1.3.2.rc1/src/api/netdb.c
--- lwip-1.3.2.rc1-unix//src/api/netdb.c	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/api/netdb.c	2010-12-22 15:04:46.250503999 -0500
@@ -314,7 +314,6 @@
   /* set up sockaddr */
   sa->sin_addr.s_addr = addr.addr;
   sa->sin_family = AF_INET;
-  sa->sin_len = sizeof(struct sockaddr_in);
   sa->sin_port = htons(port_nr);
 
   /* set up addrinfo */
diff -Nur lwip-1.3.2.rc1-unix//src/api/sockets.c lwip-1.3.2.rc1/src/api/sockets.c
--- lwip-1.3.2.rc1-unix//src/api/sockets.c	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/api/sockets.c	2010-12-22 15:04:46.250503999 -0500
@@ -170,12 +170,17 @@
 /**
  * Initialize this module. This function has to be called before any other
  * functions in this module!
+ *
+ * Update in nexus patch: made it safe to call this function multiple times.
+ * Useful to be able to stuff it behind the libc:socket() call
  */
 void
 lwip_socket_init(void)
 {
-  socksem   = sys_sem_new(1);
-  selectsem = sys_sem_new(1);
+  if (!socksem)
+    socksem   = sys_sem_new(1);
+  if (!selectsem)
+    selectsem = sys_sem_new(1);
 }
 
 /**
@@ -287,7 +292,6 @@
   if (NULL != addr) {
     LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
     memset(&sin, 0, sizeof(sin));
-    sin.sin_len = sizeof(sin);
     sin.sin_family = AF_INET;
     sin.sin_port = htons(port);
     sin.sin_addr.s_addr = naddr.addr;
@@ -570,7 +574,6 @@
         }
 
         memset(&sin, 0, sizeof(sin));
-        sin.sin_len = sizeof(sin);
         sin.sin_family = AF_INET;
         sin.sin_port = htons(port);
         sin.sin_addr.s_addr = addr->addr;
@@ -881,6 +884,30 @@
 
 
 /**
+ * Without blocking, test whether a descriptor is ready for reading or writing
+ */
+int
+lwip_poll(int fd) {
+  struct lwip_socket *p_sock;
+  int ret;
+
+  p_sock = get_socket(fd);
+  if (!p_sock) {
+  	fprintf(stderr, "lwip_poll: no socket %d\n", fd);
+	return -1;
+  }
+
+  ret = 0;
+  if (p_sock->lastdata || p_sock->rcvevent > 0)
+	  ret |= 1;		// IPC_READ
+  if (p_sock->sendevent)
+	  ret |= 2;		// IPC_WRITE
+
+  return ret;
+}
+
+
+/**
  * Processing exceptset is not yet implemented.
  */
 int
@@ -1036,6 +1063,7 @@
 static void
 event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
 {
+  extern int IPC_Wake(int port_num, int dir);
   int s;
   struct lwip_socket *sock;
   struct lwip_select_cb *scb;
@@ -1075,6 +1103,7 @@
   switch (evt) {
     case NETCONN_EVT_RCVPLUS:
       sock->rcvevent++;
+      IPC_Wake(nexusif_port, 1 /* IPC_RECV */);
       break;
     case NETCONN_EVT_RCVMINUS:
       sock->rcvevent--;
@@ -1146,7 +1175,6 @@
     return -1;
 
   memset(&sin, 0, sizeof(sin));
-  sin.sin_len = sizeof(sin);
   sin.sin_family = AF_INET;
 
   /* get the IP address and port */
diff -Nur lwip-1.3.2.rc1-unix//src/arch/sys_arch.c lwip-1.3.2.rc1/src/arch/sys_arch.c
--- lwip-1.3.2.rc1-unix//src/arch/sys_arch.c	2010-12-22 15:01:14.926503999 -0500
+++ lwip-1.3.2.rc1/src/arch/sys_arch.c	2010-12-22 15:04:46.250503999 -0500
@@ -53,6 +53,9 @@
 #include <unistd.h>
 #include <pthread.h>
 
+#include <nexus/sema.h>
+#include <nexus/rdtsc.h>
+
 #include "lwip/sys.h"
 #include "lwip/opt.h"
 #include "lwip/stats.h"
@@ -60,27 +63,32 @@
 #define UMAX(a, b)      ((a) > (b) ? (a) : (b))
 
 static struct sys_thread *threads = NULL;
-static pthread_mutex_t threads_mutex = PTHREAD_MUTEX_INITIALIZER;
+static Sema threads_mutex = SEMA_MUTEX_INIT;
 
 struct sys_mbox_msg {
   struct sys_mbox_msg *next;
   void *msg;
 };
 
-#define SYS_MBOX_SIZE 128
+#define SYS_MBOX_SIZE 256
 
 struct sys_mbox {
-  int first, last;
+  int reader, writer;
   void *msgs[SYS_MBOX_SIZE];
-  struct sys_sem *mail;
-  struct sys_sem *mutex;
-  int wait_send;
+  CondVar cv_full;
+  CondVar cv_empty;
+  Sema mutex;
 };
 
 struct sys_sem {
-  unsigned int c;
-  pthread_cond_t cond;
-  pthread_mutex_t mutex;
+#define USE_SEMA
+#ifdef USE_SEMA
+  Sema sema;
+#else
+  Sema mutex;
+  CondVar cv;
+  int count;
+#endif
 };
 
 struct sys_thread {
@@ -92,16 +100,9 @@
 
 static struct timeval starttime;
 
-static pthread_mutex_t lwprot_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_t lwprot_thread = (pthread_t) 0xDEAD;
-static int lwprot_count = 0;
-
 static struct sys_sem *sys_sem_new_(u8_t count);
 static void sys_sem_free_(struct sys_sem *sem);
 
-static u32_t cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex,
-                       u32_t timeout);
-
 /*-----------------------------------------------------------------------------------*/
 static struct sys_thread * 
 introduce_thread(pthread_t id)
@@ -111,12 +112,12 @@
   thread = malloc(sizeof(struct sys_thread));
     
   if (thread != NULL) {
-    pthread_mutex_lock(&threads_mutex);
+    P(&threads_mutex);
     thread->next = threads;
     thread->timeouts.next = NULL;
     thread->pthread = id;
     threads = thread;
-    pthread_mutex_unlock(&threads_mutex);
+    V_nexus(&threads_mutex);
   }
     
   return thread;
@@ -128,17 +129,17 @@
   struct sys_thread *st;
   pthread_t pt;
   pt = pthread_self();
-  pthread_mutex_lock(&threads_mutex);
+  P(&threads_mutex);
 
   for(st = threads; st != NULL; st = st->next) {    
     if (pthread_equal(st->pthread, pt)) {
-      pthread_mutex_unlock(&threads_mutex);
+      V_nexus(&threads_mutex);
       
       return st;
     }
   }
 
-  pthread_mutex_unlock(&threads_mutex);
+  V_nexus(&threads_mutex);
 
   st = introduce_thread(pt);
 
@@ -180,13 +181,13 @@
 {
   struct sys_mbox *mbox;
   
-  mbox = malloc(sizeof(struct sys_mbox));
+  mbox = calloc(1, sizeof(struct sys_mbox));
   if (mbox != NULL) {
-    mbox->first = mbox->last = 0;
-    mbox->mail = sys_sem_new_(0);
-    mbox->mutex = sys_sem_new_(1);
-    mbox->wait_send = 0;
-  
+    mbox->reader = mbox->writer = 0;
+    mbox->cv_full = CONDVAR_INIT;
+    mbox->cv_empty = CONDVAR_INIT;
+    mbox->mutex = SEMA_MUTEX_INIT;
+
 #if SYS_STATS
     lwip_stats.sys.mbox.used++;
     if (lwip_stats.sys.mbox.used > lwip_stats.sys.mbox.max) {
@@ -204,287 +205,170 @@
 #if SYS_STATS
     lwip_stats.sys.mbox.used--;
 #endif /* SYS_STATS */
-    sys_sem_wait(mbox->mutex);
-    
-    sys_sem_free_(mbox->mail);
-    sys_sem_free_(mbox->mutex);
-    mbox->mail = mbox->mutex = NULL;
-    /*  LWIP_DEBUGF("sys_mbox_free: mbox 0x%lx\n", mbox); */
+    P(&mbox->mutex);
+
+    CondVar_release(&mbox->cv_full);
+    CondVar_release(&mbox->cv_empty);
+    sema_release(&mbox->mutex);
     free(mbox);
   }
 }
 /*-----------------------------------------------------------------------------------*/
-err_t
-sys_mbox_trypost(struct sys_mbox *mbox, void *msg)
+static inline void
+post_internal(struct sys_mbox *mbox, void *msg)
 {
-  u8_t first;
-  
-  sys_sem_wait(mbox->mutex);
+  mbox->msgs[mbox->writer % SYS_MBOX_SIZE] = msg;
+  //fprintf(stderr, "mbox w %p.%d\n", mbox, mbox->writer);
+  mbox->writer++;
   
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_trypost: mbox %p msg %p\n",
-                          (void *)mbox, (void *)msg));
+  if (mbox->writer == mbox->reader + 1)
+    CondVar_signal(&mbox->cv_empty);
   
-  if ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE))
+  V_nexus(&mbox->mutex);
+}
+	
+err_t
+sys_mbox_trypost(struct sys_mbox *mbox, void *msg)
+{
+  P(&mbox->mutex);
+  if ((mbox->writer) == (mbox->reader + SYS_MBOX_SIZE - 1)) {
+    V_nexus(&mbox->mutex);
     return ERR_MEM;
-
-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-  
-  if (mbox->last == mbox->first) {
-    first = 1;
-  } else {
-    first = 0;
-  }
-  
-  mbox->last++;
-  
-  if (first) {
-    sys_sem_signal(mbox->mail);
   }
 
-  sys_sem_signal(mbox->mutex);
-
+  post_internal(mbox, msg);
   return ERR_OK;
 }
-/*-----------------------------------------------------------------------------------*/
+
 void
 sys_mbox_post(struct sys_mbox *mbox, void *msg)
 {
-  u8_t first;
-  
-  sys_sem_wait(mbox->mutex);
-  
-  LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_post: mbox %p msg %p\n", (void *)mbox, (void *)msg));
-  
-  while ((mbox->last + 1) >= (mbox->first + SYS_MBOX_SIZE)) {
-    mbox->wait_send++;
-    sys_sem_signal(mbox->mutex);
-    sys_arch_sem_wait(mbox->mail, 0);
-    sys_arch_sem_wait(mbox->mutex, 0);
-    mbox->wait_send--;
-  }
-  
-  mbox->msgs[mbox->last % SYS_MBOX_SIZE] = msg;
-  
-  if (mbox->last == mbox->first) {
-    first = 1;
-  } else {
-    first = 0;
-  }
-  
-  mbox->last++;
-  
-  if (first) {
-    sys_sem_signal(mbox->mail);
-  }
+  P(&mbox->mutex);
+  while ((mbox->writer) == (mbox->reader + SYS_MBOX_SIZE - 1))
+    CondVar_wait(&mbox->cv_full, &mbox->mutex);
 
-  sys_sem_signal(mbox->mutex);
+  post_internal(mbox, msg);  
 }
 /*-----------------------------------------------------------------------------------*/
-u32_t
-sys_arch_mbox_tryfetch(struct sys_mbox *mbox, void **msg)
-{
-  sys_arch_sem_wait(mbox->mutex, 0);
 
-  if (mbox->first == mbox->last) {
-    sys_sem_signal(mbox->mutex);
-    return SYS_MBOX_EMPTY;
-  }
+static inline void
+fetch_internal(struct sys_mbox *mbox, void **msg)
+{
+  if (msg != NULL)
+    *msg = mbox->msgs[mbox->reader % SYS_MBOX_SIZE];
+  //fprintf(stderr, "mbox r %p.%d\n", mbox, mbox->reader);
+  mbox->reader++;
+  
+  if (mbox->writer == (mbox->reader - 1  + SYS_MBOX_SIZE - 1))
+    CondVar_signal(&mbox->cv_full);
 
-  if (msg != NULL) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p msg %p\n", (void *)mbox, *msg));
-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-  }
-  else{
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_tryfetch: mbox %p, null msg\n", (void *)mbox));
-  }
+  V_nexus(&mbox->mutex);
+}
 
-  mbox->first++;
+u32_t
+sys_arch_mbox_tryfetch(struct sys_mbox *mbox, void **msg)
+{
+  P(&mbox->mutex);
   
-  if (mbox->wait_send) {
-    sys_sem_signal(mbox->mail);
+  if (mbox->reader == mbox->writer) {
+    V_nexus(&mbox->mutex);
+    return SYS_MBOX_EMPTY;
   }
 
-  sys_sem_signal(mbox->mutex);
-
+  fetch_internal(mbox, msg);
   return 0;
 }
-/*-----------------------------------------------------------------------------------*/
 u32_t
 sys_arch_mbox_fetch(struct sys_mbox *mbox, void **msg, u32_t timeout)
 {
-  u32_t time = 0;
-  
-  /* The mutex lock is quick so we don't bother with the timeout
-     stuff here. */
-  sys_arch_sem_wait(mbox->mutex, 0);
+  P(&mbox->mutex);
 
-  while (mbox->first == mbox->last) {
-    sys_sem_signal(mbox->mutex);
-    
-    /* We block while waiting for a mail to arrive in the mailbox. We
-       must be prepared to timeout. */
-    if (timeout != 0) {
-      time = sys_arch_sem_wait(mbox->mail, timeout);
-      
-      if (time == SYS_ARCH_TIMEOUT) {
-        return SYS_ARCH_TIMEOUT;
-      }
-    } else {
-      sys_arch_sem_wait(mbox->mail, 0);
+  while (mbox->reader == mbox->writer) {
+    if (!CondVar_timedwait(&mbox->cv_empty, &mbox->mutex, 1000 * timeout)) { 
+      V_nexus(&mbox->mutex);
+      return SYS_ARCH_TIMEOUT;
     }
-    
-    sys_arch_sem_wait(mbox->mutex, 0);
   }
 
-  if (msg != NULL) {
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p msg %p\n", (void *)mbox, *msg));
-    *msg = mbox->msgs[mbox->first % SYS_MBOX_SIZE];
-  }
-  else{
-    LWIP_DEBUGF(SYS_DEBUG, ("sys_mbox_fetch: mbox %p, null msg\n", (void *)mbox));
-  }
-
-  mbox->first++;
-  
-  if (mbox->wait_send) {
-    sys_sem_signal(mbox->mail);
-  }
-
-  sys_sem_signal(mbox->mutex);
-
-  return time;
+  fetch_internal(mbox, msg);
+  return timeout;
 }
 /*-----------------------------------------------------------------------------------*/
+
 struct sys_sem *
 sys_sem_new(u8_t count)
 {
-#if SYS_STATS
-  lwip_stats.sys.sem.used++;
-  if (lwip_stats.sys.sem.used > lwip_stats.sys.sem.max) {
-    lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
-  }
-#endif /* SYS_STATS */
-  return sys_sem_new_(count);
-}
-
-/*-----------------------------------------------------------------------------------*/
-static struct sys_sem *
-sys_sem_new_(u8_t count)
-{
   struct sys_sem *sem;
   
-  sem = malloc(sizeof(struct sys_sem));
-  if (sem != NULL) {
-    sem->c = count;
-    pthread_cond_init(&(sem->cond), NULL);
-    pthread_mutex_init(&(sem->mutex), NULL);
-  }
+  sem = calloc(1, sizeof(struct sys_sem));
+#ifdef USE_SEMA
+  sema_set(&sem->sema, count);
+#else
+  sem->mutex = SEMA_MUTEX_INIT;
+  sem->count = count;
+#endif
   return sem;
 }
 
-/*-----------------------------------------------------------------------------------*/
-static u32_t
-cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex, u32_t timeout)
-{
-  int tdiff;
-  unsigned long sec, usec;
-  struct timeval rtime1, rtime2;
-  struct timespec ts;
-  struct timezone tz;
-  int retval;
-  
-  if (timeout > 0) {
-    /* Get a timestamp and add the timeout value. */
-    gettimeofday(&rtime1, &tz);
-    sec = rtime1.tv_sec;
-    usec = rtime1.tv_usec;
-    usec += timeout % 1000 * 1000;
-    sec += (int)(timeout / 1000) + (int)(usec / 1000000);
-    usec = usec % 1000000;
-    ts.tv_nsec = usec * 1000;
-    ts.tv_sec = sec;
-    
-    retval = pthread_cond_timedwait(cond, mutex, &ts);
-    
-    if (retval == ETIMEDOUT) {
-      return SYS_ARCH_TIMEOUT;
-    } else {
-      /* Calculate for how long we waited for the cond. */
-      gettimeofday(&rtime2, &tz);
-      tdiff = (rtime2.tv_sec - rtime1.tv_sec) * 1000 +
-        (rtime2.tv_usec - rtime1.tv_usec) / 1000;
-      
-      if (tdiff <= 0) {
-        return 0;
-      }
-      
-      return tdiff;
-    }
-  } else {
-    pthread_cond_wait(cond, mutex);
-    return SYS_ARCH_TIMEOUT;
-  }
-}
-/*-----------------------------------------------------------------------------------*/
 u32_t
 sys_arch_sem_wait(struct sys_sem *sem, u32_t timeout)
 {
-  u32_t time = 0;
-  
-  pthread_mutex_lock(&(sem->mutex));
-  while (sem->c <= 0) {
-    if (timeout > 0) {
-      time = cond_wait(&(sem->cond), &(sem->mutex), timeout);
-      
-      if (time == SYS_ARCH_TIMEOUT) {
-        pthread_mutex_unlock(&(sem->mutex));
-        return SYS_ARCH_TIMEOUT;
-      }
-      /*      pthread_mutex_unlock(&(sem->mutex));
-              return time; */
-    } else {
-      cond_wait(&(sem->cond), &(sem->mutex), 0);
-    }
-  }
-  sem->c--;
-  pthread_mutex_unlock(&(sem->mutex));
-  return time;
+#ifdef USE_SEMA
+  return P_timed(&sem->sema, timeout * 1000) ? 0 : SYS_ARCH_TIMEOUT;
+#else
+  uint64_t tdiff;
+  int timedout = 0;
+
+  tdiff = rdtsc64();
+  
+  P(&sem->mutex);
+  sem->count--;
+  if (sem->count < 0) {
+	  timedout = CondVar_timedwait(&sem->cv, &sem->mutex, timeout * 1000) ? 0 : 1;
+
+	  if (timedout) {
+		  sem->count++; 	// noone signaled
+	  }
+  }
+
+  V_nexus(&sem->mutex);
+
+  tdiff = rdtsc64() - tdiff;
+  tdiff /= (3000 * 1000);	// 2GHz: good enough approx.
+  return timedout ? SYS_ARCH_TIMEOUT : (u32_t) tdiff;
+#endif
 }
-/*-----------------------------------------------------------------------------------*/
+
 void
 sys_sem_signal(struct sys_sem *sem)
 {
-  pthread_mutex_lock(&(sem->mutex));
-  sem->c++;
-
-  if (sem->c > 1) {
-    sem->c = 1;
+#ifdef USE_SEMA
+  V_nexus(&sem->sema);
+#else
+  P(&sem->mutex);
+  sem->count++;
+  if (sem->count <= 0) {
+	  CondVar_signal(&sem->cv);
   }
-
-  pthread_cond_broadcast(&(sem->cond));
-  pthread_mutex_unlock(&(sem->mutex));
+  V_nexus(&sem->mutex);
+#endif
 }
-/*-----------------------------------------------------------------------------------*/
+
 void
 sys_sem_free(struct sys_sem *sem)
 {
   if (sem != SYS_SEM_NULL) {
-#if SYS_STATS
-    lwip_stats.sys.sem.used--;
-#endif /* SYS_STATS */
-    sys_sem_free_(sem);
+#ifdef USE_SEMA
+    sema_release(&sem->sema);
+#else
+    CondVar_release(&sem->cv);
+    sema_release(&sem->mutex);
+#endif
+    free(sem);
   }
 }
 
 /*-----------------------------------------------------------------------------------*/
-static void
-sys_sem_free_(struct sys_sem *sem)
-{
-  pthread_cond_destroy(&(sem->cond));
-  pthread_mutex_destroy(&(sem->mutex));
-  free(sem);
-}
-/*-----------------------------------------------------------------------------------*/
 unsigned long
 sys_unix_now()
 {
@@ -504,8 +388,7 @@
 void
 sys_init()
 {
-  struct timezone tz;
-  gettimeofday(&starttime, &tz);
+  gettimeofday(&starttime, NULL);
 }
 /*-----------------------------------------------------------------------------------*/
 struct sys_timeouts *
@@ -517,6 +400,11 @@
   return &thread->timeouts;
 }
 /*-----------------------------------------------------------------------------------*/
+
+static Sema lwprot_mutex = SEMA_MUTEX_INIT;
+static pthread_t lwprot_thread;
+static int lwprot_count;
+
 /** sys_prot_t sys_arch_protect(void)
 
 This optional function does a "fast" critical region protection and returns
@@ -541,7 +429,7 @@
     {
         /* We are locking the mutex where it has not been locked before *
         * or is being locked by another thread */
-        pthread_mutex_lock(&lwprot_mutex);
+        P(&lwprot_mutex);
         lwprot_thread = pthread_self();
         lwprot_count = 1;
     }
@@ -566,7 +454,7 @@
         if (--lwprot_count == 0)
         {
             lwprot_thread = (pthread_t) 0xDEAD;
-            pthread_mutex_unlock(&lwprot_mutex);
+            V_nexus(&lwprot_mutex);
         }
     }
 }
diff -Nur lwip-1.3.2.rc1-unix//src/core/dns.c lwip-1.3.2.rc1/src/core/dns.c
--- lwip-1.3.2.rc1-unix//src/core/dns.c	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/core/dns.c	2010-12-22 15:04:46.250503999 -0500
@@ -84,7 +84,7 @@
 
 /** DNS server IP address */
 #ifndef DNS_SERVER_ADDRESS
-#define DNS_SERVER_ADDRESS        inet_addr("208.67.222.222") /* resolver1.opendns.com */
+#define DNS_SERVER_ADDRESS        lwip_inet_addr("208.67.222.222") /* resolver1.opendns.com */
 #endif
 
 /** DNS server port address */
diff -Nur lwip-1.3.2.rc1-unix//src/core/ipv4/inet.c lwip-1.3.2.rc1/src/core/ipv4/inet.c
--- lwip-1.3.2.rc1-unix//src/core/ipv4/inet.c	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/core/ipv4/inet.c	2010-12-22 15:04:46.250503999 -0500
@@ -58,11 +58,11 @@
  * @return ip address in network order
  */
 u32_t
-inet_addr(const char *cp)
+lwip_inet_addr(const char *cp)
 {
   struct in_addr val;
 
-  if (inet_aton(cp, &val)) {
+  if (lwip_inet_aton(cp, &val)) {
     return (val.s_addr);
   }
   return (INADDR_NONE);
@@ -72,7 +72,7 @@
  * Check whether "cp" is a valid ascii representation
  * of an Internet address and convert to a binary address.
  * Returns 1 if the address is valid, 0 if not.
- * This replaces inet_addr, the return value from which
+ * This replaces lwip_inet_addr, the return value from which
  * cannot distinguish between failure and a local broadcast address.
  *
  * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
@@ -80,7 +80,7 @@
  * @return 1 if cp could be converted to addr, 0 on failure
  */
 int
-inet_aton(const char *cp, struct in_addr *addr)
+lwip_inet_aton(const char *cp, struct in_addr *addr)
 {
   u32_t val;
   u8_t base;
diff -Nur lwip-1.3.2.rc1-unix//src/core/ipv4/ip.c lwip-1.3.2.rc1/src/core/ipv4/ip.c
--- lwip-1.3.2.rc1-unix//src/core/ipv4/ip.c	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/core/ipv4/ip.c	2010-12-22 15:04:46.250503999 -0500
@@ -560,6 +560,13 @@
     IPH_ID_SET(iphdr, htons(ip_id));
     ++ip_id;
 
+// In Nexus, force sending out to kernel
+// to let kernel filter decide where to send
+#ifndef NONEXUS
+    extern struct netif *nexusif;
+    netif = nexusif;
+#endif
+
     if (ip_addr_isany(src)) {
       ip_addr_set(&(iphdr->src), &(netif->ip_addr));
     } else {
@@ -581,7 +588,7 @@
   LWIP_DEBUGF(IP_DEBUG, ("ip_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], netif->num));
   ip_debug_print(p);
 
-#if ENABLE_LOOPBACK
+#if NONEXUS
   if (ip_addr_cmp(dest, &netif->ip_addr)) {
     /* Packet to self, enqueue it for loopback */
     LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
diff -Nur lwip-1.3.2.rc1-unix//src/core/udp.c lwip-1.3.2.rc1/src/core/udp.c
--- lwip-1.3.2.rc1-unix//src/core/udp.c	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/core/udp.c	2010-12-22 15:04:46.254503999 -0500
@@ -655,6 +655,7 @@
                (u16_t)((ntohl(pcb->local_ip.addr) >> 16) & 0xff),
                (u16_t)((ntohl(pcb->local_ip.addr) >> 8) & 0xff),
                (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
+
   return ERR_OK;
 }
 /**
diff -Nur lwip-1.3.2.rc1-unix//src/include/ipv4/lwip/inet.h lwip-1.3.2.rc1/src/include/ipv4/lwip/inet.h
--- lwip-1.3.2.rc1-unix//src/include/ipv4/lwip/inet.h	2009-10-28 11:17:24.000000000 -0400
+++ lwip-1.3.2.rc1/src/include/ipv4/lwip/inet.h	2010-12-22 15:04:46.254503999 -0500
@@ -48,8 +48,8 @@
 #define INADDR_ANY          ((u32_t)0x00000000UL)  /* 0.0.0.0 */
 #define INADDR_BROADCAST    ((u32_t)0xffffffffUL)  /* 255.255.255.255 */
 
-u32_t inet_addr(const char *cp);
-int inet_aton(const char *cp, struct in_addr *addr);
+u32_t lwip_inet_addr(const char *cp);
+int lwip_inet_aton(const char *cp, struct in_addr *addr);
 char *inet_ntoa(struct in_addr addr); /* returns ptr to static buffer; not reentrant! */
 
 #ifdef htons
diff -Nur lwip-1.3.2.rc1-unix//src/include/lwip/arch.h lwip-1.3.2.rc1/src/include/lwip/arch.h
--- lwip-1.3.2.rc1-unix//src/include/lwip/arch.h	2010-12-22 15:01:14.930503999 -0500
+++ lwip-1.3.2.rc1/src/include/lwip/arch.h	2010-12-22 15:04:46.254503999 -0500
@@ -42,7 +42,7 @@
 #define BIG_ENDIAN 4321
 #endif
 
-#include "arch/cc.h"
+#include "lwip/arch/cc.h"
 
 /** Temporary: define format string for size_t if not defined in cc.h */
 #ifndef SZT_F
diff -Nur lwip-1.3.2.rc1-unix//src/include/lwip/def.h lwip-1.3.2.rc1/src/include/lwip/def.h
--- lwip-1.3.2.rc1-unix//src/include/lwip/def.h	2009-10-28 11:17:24.000000000 -0400
+++ lwip-1.3.2.rc1/src/include/lwip/def.h	2010-12-22 15:04:46.254503999 -0500
@@ -32,6 +32,10 @@
 #ifndef __LWIP_DEF_H__
 #define __LWIP_DEF_H__
 
+/** Nexus: should not be declared here */
+int Net_filter_ipport(int istcp, unsigned short ipport, int ipcport); 
+extern int nexusif_port; 
+
 /* this might define NULL already */
 #include "lwip/arch.h"
 
diff -Nur lwip-1.3.2.rc1-unix//src/include/lwip/lwipopts.h lwip-1.3.2.rc1/src/include/lwip/lwipopts.h
--- lwip-1.3.2.rc1-unix//src/include/lwip/lwipopts.h	2010-12-22 15:01:14.930503999 -0500
+++ lwip-1.3.2.rc1/src/include/lwip/lwipopts.h	2010-12-22 15:04:46.254503999 -0500
@@ -38,6 +38,25 @@
 #ifndef __LWIPOPTS_H__
 #define __LWIPOPTS_H__
 
+//#define LWIP_DEBUG				1
+//#define UDP_DEBUG				LWIP_DBG_ON
+#define LWIP_NETIF_LOOPBACK			1
+#define LWIP_NETIF_API				1
+
+#define CHECKSUM_GEN_IP                 	0
+#define CHECKSUM_GEN_UDP                	0
+#define CHECKSUM_GEN_TCP                	0
+#define CHECKSUM_CHECK_IP               	0
+#define CHECKSUM_CHECK_UDP              	0
+#define CHECKSUM_CHECK_TCP              	0
+
+#define TCP_MSS				(1460)
+#define TCP_SND_BUF			(256 * TCP_MSS)
+#define TCP_SNDLOWAT			(256)
+#define TCP_SND_QUEUELEN		(512)
+#define TCP_WND				((1 << 16) - 1)	
+#define PBUF_POOL_BUFSIZE		(2048)
+
 /*
  * Include user defined options first. Anything not defined in these files
  * will be set to standard values. Override anything you dont like!
@@ -55,7 +74,7 @@
  * critical regions during buffer allocation, deallocation and memory
  * allocation and deallocation.
  */
-#define SYS_LIGHTWEIGHT_PROT            0
+#define SYS_LIGHTWEIGHT_PROT            1
 
 /** 
  * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
@@ -80,7 +99,7 @@
  * MEM_SIZE: the size of the heap memory. If the application will send
  * a lot of data that needs to be copied, this should be set high.
  */
-#define MEM_SIZE                        8192
+#define MEM_SIZE                        (1 << 21)
 
 /*
    ------------------------------------------------
@@ -92,44 +111,44 @@
  * If the application sends a lot of data out of ROM (or other static memory),
  * this should be set high.
  */
-#define MEMP_NUM_PBUF                   16
+#define MEMP_NUM_PBUF                   128
 
 /**
  * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
  * (requires the LWIP_RAW option)
  */
-#define MEMP_NUM_RAW_PCB                4
+#define MEMP_NUM_RAW_PCB                64
 
 /**
  * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
  * per active UDP "connection".
  * (requires the LWIP_UDP option)
  */
-#define MEMP_NUM_UDP_PCB                4
+#define MEMP_NUM_UDP_PCB                (1 << 10)
 
 /**
  * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
  * (requires the LWIP_TCP option)
  */
-#define MEMP_NUM_TCP_PCB                4
+#define MEMP_NUM_TCP_PCB                (1 << 10)
 
 /**
  * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
  * (requires the LWIP_TCP option)
  */
-#define MEMP_NUM_TCP_PCB_LISTEN         4
+#define MEMP_NUM_TCP_PCB_LISTEN         (1 << 8)
 
 /**
  * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
  * (requires the LWIP_TCP option)
  */
-#define MEMP_NUM_TCP_SEG                16
+#define MEMP_NUM_TCP_SEG                (1 << 10)
 
 /**
  * MEMP_NUM_REASSDATA: the number of simultaneously IP packets queued for
  * reassembly (whole packets, not fragments!)
  */
-#define MEMP_NUM_REASSDATA              1
+#define MEMP_NUM_REASSDATA              4
 
 /**
  * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
@@ -137,7 +156,7 @@
  * their destination address) to finish.
  * (requires the ARP_QUEUEING option)
  */
-#define MEMP_NUM_ARP_QUEUE              2
+#define MEMP_NUM_ARP_QUEUE              8
 
 /**
  * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
@@ -149,32 +168,32 @@
  * MEMP_NUM_NETBUF: the number of struct netbufs.
  * (only needed if you use the sequential API, like api_lib.c)
  */
-#define MEMP_NUM_NETBUF                 2
+#define MEMP_NUM_NETBUF                 (1 << 10)
 
 /**
  * MEMP_NUM_NETCONN: the number of struct netconns.
  * (only needed if you use the sequential API, like api_lib.c)
  */
-#define MEMP_NUM_NETCONN                4
+#define MEMP_NUM_NETCONN                (1 << 9)
 
 /**
  * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
  * for callback/timeout API communication. 
  * (only needed if you use tcpip.c)
  */
-#define MEMP_NUM_TCPIP_MSG_API          8
+#define MEMP_NUM_TCPIP_MSG_API          (1 << 10)
 
 /**
  * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
  * for incoming packets. 
  * (only needed if you use tcpip.c)
  */
-#define MEMP_NUM_TCPIP_MSG_INPKT        8
+#define MEMP_NUM_TCPIP_MSG_INPKT        (1 << 10)
 
 /**
  * PBUF_POOL_SIZE: the number of buffers in the pbuf pool. 
  */
-#define PBUF_POOL_SIZE                  8
+#define PBUF_POOL_SIZE                  (1 << 10)
 
 /*
    ---------------------------------
@@ -239,7 +258,7 @@
  * fragmentation. Otherwise pbufs are allocated and reference the original
     * packet data to be fragmented.
 */
-#define IP_FRAG_USES_STATIC_BUF         0
+#define IP_FRAG_USES_STATIC_BUF         1
 
 /**
  * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
@@ -352,7 +371,7 @@
  * link level header. The default is 14, the standard value for
  * Ethernet.
  */
-#define PBUF_LINK_HLEN                  16
+#define PBUF_LINK_HLEN                  14
 
 /**
  * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
@@ -360,7 +379,6 @@
  * TCP_MSS, IP header, and link header.
 *
  */
-#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
 
 /*
    ------------------------------------
@@ -393,6 +411,8 @@
  */
 #define LWIP_SOCKET                     1
 
+#define LWIP_COMPAT_SOCKETS             0
+
 /*
    ----------------------------------------
    ---------- Statistics options ----------
diff -Nur lwip-1.3.2.rc1-unix//src/include/lwip/sockets.h lwip-1.3.2.rc1/src/include/lwip/sockets.h
--- lwip-1.3.2.rc1-unix//src/include/lwip/sockets.h	2009-10-28 11:17:24.000000000 -0400
+++ lwip-1.3.2.rc1/src/include/lwip/sockets.h	2010-12-22 15:04:46.254503999 -0500
@@ -49,7 +49,6 @@
 
 /* members are in network byte order */
 struct sockaddr_in {
-  u8_t sin_len;
   u8_t sin_family;
   u16_t sin_port;
   struct in_addr sin_addr;
@@ -57,7 +56,6 @@
 };
 
 struct sockaddr {
-  u8_t sa_len;
   u8_t sa_family;
   char sa_data[14];
 };
diff -Nur lwip-1.3.2.rc1-unix//src/include/lwip/sys.h lwip-1.3.2.rc1/src/include/lwip/sys.h
--- lwip-1.3.2.rc1-unix//src/include/lwip/sys.h	2009-10-28 11:17:23.000000000 -0400
+++ lwip-1.3.2.rc1/src/include/lwip/sys.h	2010-12-22 15:04:46.254503999 -0500
@@ -75,7 +75,7 @@
 #define SYS_MBOX_EMPTY SYS_ARCH_TIMEOUT 
 
 #include "lwip/err.h"
-#include "arch/sys_arch.h"
+#include "lwip/arch/sys_arch.h"
 
 typedef void (* sys_timeout_handler)(void *arg);
 
diff -Nur lwip-1.3.2.rc1-unix//src/netif/nexusif.c lwip-1.3.2.rc1/src/netif/nexusif.c
--- lwip-1.3.2.rc1-unix//src/netif/nexusif.c	1969-12-31 19:00:00.000000000 -0500
+++ lwip-1.3.2.rc1/src/netif/nexusif.c	2010-12-22 15:05:59.386503999 -0500
@@ -0,0 +1,298 @@
+/**
+ * @file
+ * Nexus Interface 
+ * Communicates with the Nexus kernel over IPC
+ * 
+ */
+
+#include <stdio.h>
+#include <pthread.h>
+
+#include "lwip/opt.h"
+
+#include "lwip/def.h"
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/sys.h"
+#include "lwip/stats.h"
+#include "lwip/snmp.h"
+#include "netif/etharp.h"
+
+#include <nexus/net.h>
+#include <nexus/syscalls.h>
+#include <nexus/IPC.interface.h>
+#include <nexus/Net.interface.h>
+
+/* Define those to better describe your network interface. */
+#define IFNAME0 'n'
+#define IFNAME1 'x'
+
+/* Forward declarations. */
+static void nexusif_input(struct netif *netif, void *page);
+
+/** after initialization, IPC portnum of listening thread 
+    of first nexusif device in this process space. */
+int nexusif_port; 
+
+struct netif *nexusif;
+
+static void *
+low_level_rxthread(void *_netif)
+{
+  struct netif *netif = _netif;
+  char *page;
+  int ret;
+
+  Thread_SetName("net.rx");
+  while (1) {
+
+    /* get a packet from the kernel */
+    ret = Net_vrouter_from(nexusif_port, (unsigned long) &page, 0, 0);
+    if (ret <= 0) {
+      printf("nexusif: ipc rx failed\n");
+      continue;
+    }
+
+    /* send up to lwIP */
+    nexusif_input(netif, page);
+
+    /* release to the page pool */
+    nxnet_free_page(page);
+  }
+
+  /* not reached */
+  return NULL;
+}
+
+/**
+ * In this function, the hardware should be initialized.
+ * Called from nexusif_init().
+ *
+ * @param netif the already initialized lwip network interface structure
+ *        for this nexusif
+ */
+static void
+low_level_init(struct netif *netif)
+{
+  pthread_t rxthread;
+  char mac[6];
+ 
+  /* nexus: acquire MAC */
+  memset(mac, 0, 6);
+  Net_get_mac(mac);
+  LWIP_DEBUGF(NETIF_DEBUG, ("nexusif: got MAC %hx.%hx.%hx.%hx.%hx.%hx\n",
+			    mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]));
+
+  /* set MAC hardware address length */
+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+
+  /* set MAC hardware address */
+  memcpy(netif->hwaddr, mac, 6);
+
+  /* maximum transfer unit */
+  netif->mtu = 1500;
+  
+  /* device capabilities */
+  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
+ 
+  /* start nexus IPC reception thread */
+  pthread_create(&rxthread, NULL, low_level_rxthread, netif);
+}
+
+/**
+ * This function should do the actual transmission of the packet. The packet is
+ * contained in the pbuf that is passed to the function. This pbuf
+ * might be chained.
+ *
+ * @param netif the lwip network interface structure for this nexusif
+ * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+ * @return ERR_OK if the packet could be sent
+ *         an err_t value if the packet couldn't be sent
+ *
+ * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+ *       strange results. You might consider waiting for space in the DMA queue
+ *       to become availale since the stack doesn't retry to send a packet
+ *       dropped because of memory failure (except for the TCP timers).
+ */
+
+static err_t
+low_level_output(struct netif *netif, struct pbuf *p)
+{
+  struct pbuf *q;
+  char *buf;
+  unsigned long tot_len, off;
+  err_t ret = ERR_OK;
+
+#if ETH_PAD_SIZE
+  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+#endif
+
+  /* calculate length */
+  tot_len = 0;
+  for(q = p; q != NULL; q = q->next)
+    tot_len += q->len;
+    
+  /* allocate and set length */
+  buf = nxnet_alloc_page();
+  if (!buf) {
+    printf("net alloc failed\n");
+    return ERR_IF;
+  }
+  nxnet_page_setlen(buf, tot_len);
+
+  /* copy */
+  off = 0;
+  for(q = p; q != NULL; q = q->next) {
+    memcpy(buf + off, q->payload, q->len);
+    off += q->len;
+  }
+  
+  Net_vrouter_to(buf, off);
+
+#if ETH_PAD_SIZE
+  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+#endif
+  
+  LINK_STATS_INC(link.xmit);
+
+  return ret;
+}
+
+/**
+ * Should allocate a pbuf and transfer the bytes of the incoming
+ * packet from the interface into the pbuf.
+ *
+ * @param netif the lwip network interface structure for this nexusif
+ * @return a pbuf filled with the received packet (including MAC header)
+ *         NULL on memory error
+ */
+static struct pbuf *
+low_level_input(char *page)
+{
+  struct pbuf *p;
+  u16_t len, off;
+
+  /* Obtain the size of the packet and put it into the "len"
+     variable. */
+  len = nxnet_page_getlen(page);
+//printf("LWIP DEBUG: #1 receiving %dB of data. %02hhx.%02hhx.%02hhx.%02hhx\n", 
+//	len, page[0], page[1], page[2], page[3]);
+  off = 0;
+
+  /* We allocate a pbuf chain of pbufs from the pool. 
+     XXX avoid: try to use page directly
+         it's not clear if that is allowed with multithreading
+   */
+  p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
+  
+  if (p && p->len >= len) {
+    memcpy(p->payload, page, len);
+    LINK_STATS_INC(link.recv);
+  } else {
+    LWIP_DEBUGF(NETIF_DEBUG, ("nexusif: OOM: dropped packet on rx.\n"));
+    LINK_STATS_INC(link.memerr);
+    LINK_STATS_INC(link.drop);
+  }
+
+  return p;  
+}
+
+/**
+ * This function should be called when a packet is ready to be read
+ * from the interface. It uses the function low_level_input() that
+ * should handle the actual reception of bytes from the network
+ * interface. Then the type of the received packet is determined and
+ * the appropriate input function is called.
+ *
+ * @param netif the lwip network interface structure for this nexusif
+ */
+static void
+nexusif_input(struct netif *netif, void *page)
+{
+  struct eth_hdr *ethhdr;
+  struct pbuf *p;
+
+  p = low_level_input(page);
+  if (!p) {
+	printf("Failed to read incoming packet\n");
+  	return;
+  }
+
+  /* points to packet payload, which starts with an Ethernet header */
+  ethhdr = p->payload;
+
+  switch (htons(ethhdr->type)) {
+  /* IP or ARP packet? */
+  case ETHTYPE_IP:
+  case ETHTYPE_ARP:
+#if PPPOE_SUPPORT
+  /* PPPoE packet? */
+  case ETHTYPE_PPPOEDISC:
+  case ETHTYPE_PPPOE:
+#endif /* PPPOE_SUPPORT */
+    /* full packet send to tcpip_thread to process */
+//printf("LWIP DEBUG: sending %dB up\n", p->len);
+    if (netif->input(p, netif)!=ERR_OK)
+     { LWIP_DEBUGF(NETIF_DEBUG, ("nexusif_input: IP input error\n"));
+       pbuf_free(p);
+       p = NULL;
+     }
+    break;
+
+  default:
+    pbuf_free(p);
+    p = NULL;
+    break;
+  }
+}
+
+/**
+ * Should be called at the beginning of the program to set up the
+ * network interface. It calls the function low_level_init() to do the
+ * actual setup of the hardware.
+ *
+ * This function should be passed as a parameter to netif_add().
+ *
+ * @param netif the lwip network interface structure for this nexusif
+ * @return ERR_OK if the loopif is initialized
+ *         ERR_MEM if private data couldn't be allocated
+ *         any other err_t on error
+ */
+err_t
+nexusif_init(struct netif *netif)
+{
+  nexusif_port = IPC_CreatePort(0);
+  if (nexusif_port < 0) {
+    LWIP_DEBUGF(NETIF_DEBUG, ("nexusif_init: could not connect to kernel\n"));
+    return ERR_IF;
+  }
+
+#if LWIP_NETIF_HOSTNAME
+  /* Initialize interface hostname */
+  netif->hostname = "nexus";
+#endif /* LWIP_NETIF_HOSTNAME */
+
+  /*
+   * Initialize the snmp variables and counters inside the struct netif.
+   * The last argument should be replaced with your link speed, in units
+   * of bits per second.
+   */
+  NETIF_INIT_SNMP(netif, snmp_ifType_nexus_csmacd, 1000 * 1000 * 1000);
+
+  netif->name[0] = IFNAME0;
+  netif->name[1] = IFNAME1;
+  /* We directly use etharp_output() here to save a function call.
+   * You can instead declare your own function an call etharp_output()
+   * from it if you have to do some checks before sending (e.g. if link
+   * is available...) */
+  netif->output = etharp_output;
+  netif->linkoutput = low_level_output;
+  
+  /* initialize the hardware */
+  low_level_init(netif);
+
+  nexusif = netif;
+
+  return ERR_OK;
+}
+
diff -Nur lwip-1.3.2.rc1-unix//src/netif/ppp/auth.c lwip-1.3.2.rc1/src/netif/ppp/auth.c
--- lwip-1.3.2.rc1-unix//src/netif/ppp/auth.c	2009-10-28 11:17:24.000000000 -0400
+++ lwip-1.3.2.rc1/src/netif/ppp/auth.c	2010-12-22 15:04:46.254503999 -0500
@@ -943,7 +943,7 @@
       if (hp != NULL && hp->h_addrtype == AF_INET) {
         a = *(u32_t *)hp->h_addr;
       } else {
-        a = inet_addr(p);
+        a = lwip_inet_addr(p);
       }
       if (a != (u32_t) -1) {
         wo->hisaddr = a;
