diff -Nur uClibc-0.9.30.1-orig/include/sys/syscall.h uClibc-0.9.30.1/include/sys/syscall.h
--- uClibc-0.9.30.1-orig/include/sys/syscall.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/include/sys/syscall.h	2009-12-02 03:45:16.000000000 +0000
@@ -34,4 +34,26 @@
 # include <bits/syscalls.h>
 #endif
 
+/* Nexus: added direct socket system calls so that we do
+   not have to jump through yet another tunnel (socketcall()) 
+ 
+   Cannot add them to bits/sysnum.h, because that is autogenerated.
+   WARNING: this also means that with a different uclibc configuration
+            the numbering might change (?) Certainly, these numbers do
+	    not correspond with actual libc numbers.
+ */
+
+#define __NR_socket 253
+#define __NR_bind 254
+#define __NR_connect 255
+#define __NR_listen 256
+#define __NR_accept 257
+#define __NR_getsockname 258
+#define __NR_setsockopt 259
+
+#define __NR_send 260
+#define __NR_recv 261
+#define __NR_sendto 262
+#define __NR_recvfrom 263
+
 #endif
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/closedir.c uClibc-0.9.30.1/libc/misc/dirent/closedir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/closedir.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/misc/dirent/closedir.c	2009-12-02 03:45:16.000000000 +0000
@@ -13,8 +13,13 @@
 libc_hidden_proto(closedir)
 libc_hidden_proto(close)
 
+extern int nxlibc_syscall_closedir(DIR * dir);
+
 int closedir(DIR * dir)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_closedir(dir);
+#else
 	int fd;
 
 	if (!dir) {
@@ -34,5 +39,6 @@
 	free(dir->dd_buf);
 	free(dir);
 	return close(fd);
+#endif
 }
 libc_hidden_def(closedir)
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/opendir.c uClibc-0.9.30.1/libc/misc/dirent/opendir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/opendir.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/misc/dirent/opendir.c	2009-12-02 03:45:16.000000000 +0000
@@ -21,15 +21,21 @@
 libc_hidden_proto(stat)
 libc_hidden_proto(fstat)
 
+extern DIR *nxlibc_syscall_opendir(const char *name);
+
 /* opendir just makes an open() call - it return NULL if it fails
  * (open sets errno), otherwise it returns a DIR * pointer.
  */
 DIR *opendir(const char *name)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_opendir(name);
+#else
 	int fd;
 	struct stat statbuf;
 	DIR *ptr;
 
+
 #ifndef O_DIRECTORY
 	/* O_DIRECTORY is linux specific and has been around since like 2.1.x */
 	if (stat(name, &statbuf))
@@ -79,5 +85,6 @@
 	}
 	__pthread_mutex_init(&(ptr->dd_lock), NULL);
 	return ptr;
+#endif
 }
 libc_hidden_def(opendir)
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/readdir.c uClibc-0.9.30.1/libc/misc/dirent/readdir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/readdir.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/misc/dirent/readdir.c	2009-12-02 03:45:16.000000000 +0000
@@ -17,6 +17,9 @@
 
 struct dirent *readdir(DIR * dir)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_readdir(dir);
+#else
 	ssize_t bytes;
 	struct dirent *de;
 
@@ -53,5 +56,6 @@
 all_done:
 	__UCLIBC_MUTEX_UNLOCK(dir->dd_lock);
 	return de;
+#endif
 }
 libc_hidden_def(readdir)
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/rewinddir.c uClibc-0.9.30.1/libc/misc/dirent/rewinddir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/rewinddir.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/misc/dirent/rewinddir.c	2009-12-02 03:45:16.000000000 +0000
@@ -11,9 +11,14 @@
 
 libc_hidden_proto(lseek)
 
+extern void nxlibc_syscall_rewinddir(DIR * dir);
+
 /* rewinddir() just does an lseek(fd,0,0) - see close for comments */
 void rewinddir(DIR * dir)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_rewinddir(dir);
+#else
 	if (!dir) {
 		__set_errno(EBADF);
 		return;
@@ -22,4 +27,5 @@
 	lseek(dir->dd_fd, 0, SEEK_SET);
 	dir->dd_nextoff = dir->dd_nextloc = dir->dd_size = 0;
 	__UCLIBC_MUTEX_UNLOCK(dir->dd_lock);
+#endif
 }
diff -Nur uClibc-0.9.30.1-orig/libc/stdlib/malloc-standard/malloc.h uClibc-0.9.30.1/libc/stdlib/malloc-standard/malloc.h
--- uClibc-0.9.30.1-orig/libc/stdlib/malloc-standard/malloc.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/stdlib/malloc-standard/malloc.h	2009-12-02 03:45:16.000000000 +0000
@@ -122,7 +122,7 @@
    of kernel resources.
 */
 #ifndef MMAP_AS_MORECORE_SIZE
-#define MMAP_AS_MORECORE_SIZE (1024 * 1024)
+#define MMAP_AS_MORECORE_SIZE (1024 * 1024 * 1024) // XXX reset when mmap works
 #endif
 
 /*
@@ -322,7 +322,7 @@
 #define M_MMAP_THRESHOLD      -3
 
 #ifndef DEFAULT_MMAP_THRESHOLD
-#define DEFAULT_MMAP_THRESHOLD (256 * 1024)
+#define DEFAULT_MMAP_THRESHOLD (256 * 1024 * 4096) // XXX reset when mmap works
 #endif
 
 /*
diff -Nur uClibc-0.9.30.1-orig/libc/stdlib/setenv.c uClibc-0.9.30.1/libc/stdlib/setenv.c
--- uClibc-0.9.30.1-orig/libc/stdlib/setenv.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/stdlib/setenv.c	2009-12-02 03:45:16.000000000 +0000
@@ -154,6 +154,8 @@
     len = strlen (name);
     __UCLIBC_MUTEX_LOCK(mylock);
     ep = __environ;
+    if (ep == NULL) /* No environment: cannot be set */
+		return 0;
     while (*ep != NULL) {
 		if (!strncmp (*ep, name, len) && (*ep)[len] == '=') {
 			/* Found it.  Remove this pointer by moving later ones back.  */
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/llseek.c uClibc-0.9.30.1/libc/sysdeps/linux/common/llseek.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/llseek.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/llseek.c	2009-12-02 03:45:16.000000000 +0000
@@ -22,11 +22,17 @@
 		off_t, offset_lo, loff_t *, result, int, whence)
 # endif
 
+extern int nxlibc_syscall_lseek64(int fildes, int offset, int whence);
+
 loff_t __libc_lseek64(int fd, loff_t offset, int whence)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_lseek64(fd, offset, whence);
+#else
 	loff_t result;
 	return(loff_t)(INLINE_SYSCALL (_llseek, 5, fd, (off_t) (offset >> 32),
 				(off_t) (offset & 0xffffffff), &result, whence) ?: result);
+#endif
 }
 #else
 extern __typeof(lseek) __libc_lseek;
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/mount.c uClibc-0.9.30.1/libc/sysdeps/linux/common/mount.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/mount.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/mount.c	2009-12-02 03:45:16.000000000 +0000
@@ -9,6 +9,18 @@
 
 #include <sys/syscall.h>
 #include <sys/mount.h>
+
+#ifndef DISABLE_NEXUS_CHANGES
+int mount(const char *source, const char *target,
+	  const char *filesystemtype, unsigned long mountflags,
+	  const void *data)
+{
+	return nxlibc_syscall_mount(source, target, filesystemtype,
+				    mountflags, data);
+}
+
+#else
 _syscall5(int, mount, const char *, specialfile, const char *, dir,
 		  const char *, filesystemtype, unsigned long, rwflag,
 		  const void *, data)
+#endif
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/open64.c uClibc-0.9.30.1/libc/sysdeps/linux/common/open64.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/open64.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/open64.c	2009-12-02 03:45:16.000000000 +0000
@@ -18,11 +18,17 @@
 extern __typeof(open) __libc_open;
 libc_hidden_proto(__libc_open)
 
+extern int nxlibc_syscall_open64(const char *file, int oflag);
+
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
    a third argument is the file protection.  */
 libc_hidden_proto(__libc_open64)
 int __libc_open64 (const char *file, int oflag, ...)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	// XXX Nexus open64 does not support ellipsis (...)
+	return nxlibc_syscall_open64(file, oflag);
+#else
     mode_t mode = 0;
 
     if (oflag & O_CREAT)
@@ -34,6 +40,7 @@
     }
 
     return __libc_open(file, oflag | O_LARGEFILE, mode);
+#endif
 }
 libc_hidden_def(__libc_open64)
 
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/sync.c uClibc-0.9.30.1/libc/sysdeps/linux/common/sync.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/sync.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/sync.c	2009-12-02 03:45:16.000000000 +0000
@@ -20,6 +20,6 @@
 
 void sync(void)
 {
-	INLINE_SYSCALL(sync, 0);
+	_touchup_errno(intercept_syscall(__NR_sync, 0));
 }
 #endif
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/umount.c uClibc-0.9.30.1/libc/sysdeps/linux/common/umount.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/umount.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/umount.c	2009-12-02 03:45:16.000000000 +0000
@@ -12,6 +12,16 @@
 #if defined __USE_GNU
 #include <sys/mount.h>
 
+#ifndef DISABLE_NEXUS_CHANGES
+#include <stdio.h>
+int umount(const char *special_file)
+{
+	fprintf(stderr, "umount: not implemented\n");
+	errno = -EBUSY;
+	return -1;
+}
+#else
+
 /* arch provides umount() syscall */
 #ifdef __NR_umount
 
@@ -39,3 +49,4 @@
 
 #endif
 #endif
+#endif
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/kernel_stat.h uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/kernel_stat.h
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/kernel_stat.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/kernel_stat.h	2009-12-02 03:46:00.000000000 +0000
@@ -9,6 +9,7 @@
  * struct stat should look like...  It turns out each arch has a
  * different opinion on the subject... */
 
+#if 0
 struct kernel_stat {
 	unsigned short st_dev;
 	unsigned short __pad1;
@@ -55,6 +56,14 @@
 	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
 	unsigned long long	st_ino;
 };
+#else
+
+// Nexus uses libc stat structures
+
+#define kernel_stat stat
+#define kernel_stat64 stat64
+
+#endif
 
 #endif	/*  _BITS_STAT_STRUCT_H */
 
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/syscalls.h uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/syscalls.h
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/syscalls.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/syscalls.h	2009-12-02 03:45:16.000000000 +0000
@@ -102,11 +102,14 @@
      ".endm\n\t");
 #endif
 
+/* Nexus patch: for some reason we have to avoid using
+   variadic macros in case they expand to zero. */
+
 #undef _syscall0
 #define _syscall0(type,name) \
 type name(void) \
 { \
-return (type) (INLINE_SYSCALL(name, 0)); \
+return (type) (_touchup_errno(intercept_syscall(__NR_##name, 0))); \
 }
 
 #undef _syscall1
@@ -152,60 +155,22 @@
 { \
 return (type) (INLINE_SYSCALL(name, 6, arg1, arg2, arg3, arg4, arg5, arg6)); \
 }
- #define INLINE_SYSCALL(name, nr, args...) \
-  ({                                                                          \
-    unsigned int _resultvar = INTERNAL_SYSCALL (name, , nr, args);            \
-    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_resultvar, ), 0))        \
-      {                                                                       \
-        __set_errno (INTERNAL_SYSCALL_ERRNO (_resultvar, ));                  \
-        _resultvar = 0xffffffff;                                              \
-      }                                                                       \
-    (int) _resultvar; })
-
-#define INTERNAL_SYSCALL(name, err, nr, args...) \
-  ({                                                                          \
-    register unsigned int resultvar;                                          \
-    __asm__ __volatile__ (                                                            \
-    LOADARGS_##nr                                                             \
-    "movl %1, %%eax\n\t"                                                      \
-    "int $0x80\n\t"                                                           \
-    RESTOREARGS_##nr                                                          \
-    : "=a" (resultvar)                                                        \
-    : "i" (__NR_##name) ASMFMT_##nr(args) : "memory", "cc");                  \
-     (int) resultvar; })
-
-#define LOADARGS_0
-#define LOADARGS_1 \
-    "bpushl .L__X'%k2, %k2\n\t"						      \
-    "bmovl .L__X'%k2, %k2\n\t"
-#define LOADARGS_2	LOADARGS_1
-#define LOADARGS_3	LOADARGS_1
-#define LOADARGS_4	LOADARGS_1
-#define LOADARGS_5	LOADARGS_1
-#define LOADARGS_6	LOADARGS_1 "push %%ebp ; movl %7, %%ebp\n\t"
-
-#define RESTOREARGS_0
-#define RESTOREARGS_1 \
-    "bpopl .L__X'%k2, %k2\n\t"
-#define RESTOREARGS_2	RESTOREARGS_1
-#define RESTOREARGS_3	RESTOREARGS_1
-#define RESTOREARGS_4	RESTOREARGS_1
-#define RESTOREARGS_5	RESTOREARGS_1
-#define RESTOREARGS_6	"pop %%ebp\n\t" RESTOREARGS_1
-
-#define ASMFMT_0()
-#define ASMFMT_1(arg1) \
-	, "acdSD" (arg1)
-#define ASMFMT_2(arg1, arg2) \
-	, "adSD" (arg1), "c" (arg2)
-#define ASMFMT_3(arg1, arg2, arg3) \
-	, "aSD" (arg1), "c" (arg2), "d" (arg3)
-#define ASMFMT_4(arg1, arg2, arg3, arg4) \
-	, "aD" (arg1), "c" (arg2), "d" (arg3), "S" (arg4)
-#define ASMFMT_5(arg1, arg2, arg3, arg4, arg5) \
-	, "a" (arg1), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5)
-#define ASMFMT_6(arg1, arg2, arg3, arg4, arg5, arg6) \
-	, "a" (arg1), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5), "m" (arg6)
 
+long int intercept_syscall (long int nr, int argcount, ...);
+
+/** check system call result and update errno accordingly */
+static inline long int _touchup_errno(int ret)
+{
+	if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (ret, ), 0)) {
+		__set_errno (INTERNAL_SYSCALL_ERRNO (ret, ));
+		ret = 0xffffffff;                            
+	}
+	return ret;
+}
+
+#define INLINE_SYSCALL(name, nr, ...) 					\
+	 _touchup_errno(intercept_syscall(__NR_##name, nr, __VA_ARGS__))
+	 
 #endif /* __ASSEMBLER__ */
 #endif /* _BITS_SYSCALLS_H */
+
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/brk.c uClibc-0.9.30.1/libc/sysdeps/linux/i386/brk.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/brk.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/brk.c	2009-12-02 03:45:16.000000000 +0000
@@ -27,8 +27,12 @@
 libc_hidden_proto(brk)
 int brk (void *addr)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+    return INLINE_SYSCALL(brk, 1, addr);
+#else
     void *__unbounded newbrk, *__unbounded scratch;
 
+
     __asm__ ("movl %%ebx, %1\n"	/* Save %ebx in scratch register.  */
 	    "movl %3, %%ebx\n"	/* Put ADDR in %ebx to be syscall arg.  */
 	    "int $0x80 # %2\n"	/* Perform the system call.  */
@@ -45,5 +49,6 @@
     }
 
     return 0;
+#endif
 }
 libc_hidden_def(brk)
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/Makefile.arch uClibc-0.9.30.1/libc/sysdeps/linux/i386/Makefile.arch
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/Makefile.arch	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/Makefile.arch	2009-12-02 03:45:16.000000000 +0000
@@ -5,7 +5,7 @@
 # Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
 #
 
-CSRC := brk.c sigaction.c __syscall_error.c
+CSRC := brk.c sigaction.c __syscall_error.c syscall_intercept.c
 
 SSRC := \
 	__longjmp.S vfork.S clone.S setjmp.S bsd-setjmp.S bsd-_setjmp.S \
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall_intercept.c uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall_intercept.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall_intercept.c	1970-01-01 00:00:00.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall_intercept.c	2009-12-02 03:45:16.000000000 +0000
@@ -0,0 +1,257 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <sys/syscall.h>
+
+/* These are linked here by the package Makefile **/
+#include "linuxcalls.h"
+#include "linuxcalls_io.h"
+
+/** ugly and potentially DANGEROUS extern declarations */
+extern int Console_PrintString(int handle, const char *buf, int len);
+extern int printhandle;
+
+/** Write out the errorcode without using higher level snprintf and such. */
+static void
+__print_error(const char *pre, int syscall_no, const char *post)
+{
+	char syscall_nostr[] = "000";
+
+	// convert the system call code to a string
+	if (syscall_no >= 100)
+		syscall_nostr[0] = '0' + (syscall_no / 100);
+	if (syscall_no >= 10)
+		syscall_nostr[1] = '0' + (syscall_no % 100) / 10;
+	syscall_nostr[2] = '0' + syscall_no % 10;
+
+	// write to the screen
+	Console_PrintString(printhandle, pre, strlen(pre));
+	Console_PrintString(printhandle, syscall_nostr, 3);
+	Console_PrintString(printhandle, post, strlen(post));
+}
+
+/** Handle an unimplemented syscall. 
+    In good Unix fashion we break hard and noisily */
+static void 
+abort_syscall (long int nr)
+{
+	__print_error("NXLIBC ERROR: syscall #", nr, " not supported. Aborting\n");
+	intercept_syscall(__NR_exit, 1);
+}
+
+/** On unimportant syscalls, make noise, but continue. */
+static void 
+skip_syscall (long int nr)
+{
+	__print_error("NXLIBC WARNING: syscall #", nr, " not supported. Skipping\n");
+	// XXX what do we do with the return argument?
+}
+
+/** Intercept system calls and redirect the ones that nexus implements there.
+    
+    @param argcount is the number of used arguments or -1 if unknown
+    @return is return of the call if taken, -1 if skipped and
+    the function does not return on aborted calls. */
+long int 
+intercept_syscall (long int nr, int argcount, ...)
+{
+#define MAX_ARGCOUNT 6 // need not be higher than what libc can issue
+
+	va_list arglist;
+	unsigned long args[MAX_ARGCOUNT];
+	int i;
+
+	/* if number of arguments is unknown we copy all, which is slow and 
+	   may try to touch illegal addresses (segfaulting, unlikely). */
+	if (argcount == -1)
+		argcount = MAX_ARGCOUNT;
+
+	/* fetch args */
+	va_start(arglist, argcount);
+	for (i = 0; i < argcount; i++)
+		args[i] = va_arg(arglist, unsigned long);
+	va_end(arglist);
+
+	/* trace all calls */
+	//__print_error("NXLIBC info: syscall #", nr, " called\n");
+
+	switch (nr) {
+		/**** handled calls: forward call ********/
+		
+		/** Non I/O system calls *****/
+
+		case __NR_exit : 	nxlibc_syscall_do_exit((int) args[0]);
+					return -1; /* never reached */
+
+		/* memory */
+
+		case __NR_brk : 	return (long) nxlibc_syscall_brk((void *) args[0]);
+		case __NR_mprotect:	return (long) nxlibc_syscall_mprotect((const void *) args[0], 
+									      (size_t) args[1], (int) args[2]);
+		case __NR_mlock: 	return (long) nxlibc_syscall_mlock((const void *) args[0], (size_t) args[1]);
+		case __NR_munlock: 	return (long) nxlibc_syscall_munlock((const void *) args[0], (size_t) args[1]);
+
+		/* process */
+
+		case __NR_getpid:	return (long) nxlibc_syscall_getpid();
+		case __NR_fork:		return (long) nxlibc_syscall_fork();
+		case __NR_execve:	return (long) nxlibc_syscall_execve((const char *) args[0], (char **) args[1],
+									    (char **) args[2]);
+
+		/** time ****/
+
+		case __NR_nanosleep:	return (long) nxlibc_syscall_nanosleep((const struct timespec *) args[0], 
+									       (struct timespec *) args[1]);
+		case __NR_gettimeofday:	return (long) nxlibc_syscall_gettimeofday((struct timeval *) args[0], 
+										  (void *) args[1]);
+		case __NR_time:		return (long) nxlibc_syscall_time((time_t *) args[0]);
+
+		/** access control ****/
+
+		case __NR_getuid:	return (long) nxlibc_syscall_getuid();
+		case __NR_geteuid:	return (long) nxlibc_syscall_geteuid();
+		case __NR_getgid:	return (long) nxlibc_syscall_getgid();
+		case __NR_getegid:	return (long) nxlibc_syscall_getegid();
+
+		case __NR_getuid32:	return (long) nxlibc_syscall_getuid32();
+		case __NR_geteuid32:	return (long) nxlibc_syscall_geteuid32();
+		case __NR_getgid32:	return (long) nxlibc_syscall_getgid32();
+		case __NR_getegid32:	return (long) nxlibc_syscall_getegid32();
+
+		case __NR_setuid:	return (long) nxlibc_syscall_setuid((__uid_t) args[0]);
+		case __NR_setfsuid:	return (long) nxlibc_syscall_setfsuid((int) args[0]);
+		case __NR_setgid:	return (long) nxlibc_syscall_setgid((__gid_t) args[0]);
+		case __NR_setfsgid:	return (long) nxlibc_syscall_setfsgid((int) args[0]);
+
+		case __NR_setuid32:	return (long) nxlibc_syscall_setuid32((__uid_t) args[0]);
+		case __NR_setfsuid32:	return (long) nxlibc_syscall_setfsuid32((int) args[0]);
+		case __NR_setgid32:	return (long) nxlibc_syscall_setgid32((__gid_t) args[0]);
+		case __NR_setfsgid32:	return (long) nxlibc_syscall_setfsgid32((int) args[0]);
+
+		/** signal handling ****/
+
+		case __NR_rt_sigaction: 
+		case __NR_sigaction:	return (long) nxlibc_syscall_sigaction((int) args[0], (const struct sigaction *) args[1],
+									       (struct sigaction *) args[2]);
+		case __NR_signal:	return (long) nxlibc_syscall_signal((int) args[0], (sighandler_t) args[1]);
+
+		/** I/O system calls ****/
+
+		/* IO: filesystem operations */
+
+		case __NR_mkdir : 	return (long) nxlibc_syscall_mkdir((const char *) args[0], (mode_t) args[1]);
+
+		/* IO: directory operations */
+
+		case __NR_readdir:	return (long) nxlibc_syscall_readdir((DIR *) args[0]);
+		case __NR_chdir:	return (long) nxlibc_syscall_chdir((const char *) args[0]);
+		case __NR_getcwd:	return (long) nxlibc_syscall_getcwd((char *) args[0], (int) args[1]);
+
+		/* IO: file operations */
+
+		case __NR_open:		return (long) nxlibc_syscall_open((const char *) args[0], 
+									  (int) args[1], (int) args[2]);
+		case __NR_pipe:		return (long) nxlibc_syscall_pipe((int*) args[0]);
+		case __NR_dup:		return (long) nxlibc_syscall_dup((int) args[0]);
+		case __NR_dup2:		return (long) nxlibc_syscall_dup2((int) args[0], (int) args[1]);
+		case __NR_chmod:	return (long) nxlibc_syscall_chmod((const char *) args[0], (mode_t) args[1]);
+		case __NR_stat:		
+		case __NR_lstat:		
+					return (long) nxlibc_syscall_stat((const char *) args[0], (struct stat *) args[1]);
+		case __NR_stat64:		
+		case __NR_lstat64:		
+					return (long) nxlibc_syscall_stat64((const char *) args[0], (struct stat64 *) args[1]);
+		case __NR_fstat:	return (long) nxlibc_syscall_fstat((int) args[0], (struct stat *) args[1]);
+		case __NR_fstat64:	return (long) nxlibc_syscall_fstat64((int) args[0], (struct stat64 *) args[1]);
+		case __NR_umask:	return (long) nxlibc_syscall_umask((int) args[0]);
+		case __NR_unlink:	return (long) nxlibc_syscall_unlink((const char *) args[0]);
+
+		/* IO: open file operations */
+
+		case __NR_read:		return (long) nxlibc_syscall_read((int) args[0], (void *) args[1], 
+									  (size_t) args[2]);
+		case __NR_write:	return (long) nxlibc_syscall_write((int) args[0], (const void *) args[1], 
+									   (size_t) args[2]);
+		case __NR_writev:	return (long) nxlibc_syscall_writev((int) args[0], 
+									    (const struct iovec *) args[1], 
+									    (int) args[2]);
+		case __NR_close:	return (long) nxlibc_syscall_close((int) args[0]);
+
+		case __NR_ioctl: 	return (long) nxlibc_syscall_ioctl((int) args[0], (int) args[1], 
+									   (void *) args[2]);
+		case __NR_fsync:	return (long) nxlibc_syscall_fsync((int) args[0]);
+
+		case __NR_lseek:	return (long) nxlibc_syscall_lseek((int) args[0], (__off_t) args[1], 
+									   (int) args[2]);
+		case __NR_fcntl:	return (long) nxlibc_syscall_fcntl((int) args[0], (int) args[1], 
+									   (long) args[2]);
+		case __NR_fcntl64:	return (long) nxlibc_syscall_fcntl((int) args[0], (int) args[1], 
+									   (long) args[2]);
+
+		/* IO: socket state operations */
+
+		case __NR_socket:	return (long) nxlibc_syscall_socket((int) args[0], (int) args[1], 
+									    (int) args[2]);
+		case __NR_connect:	return (long) nxlibc_syscall_connect((int) args[0], 
+									     (const struct sockaddr *) args[1], 
+									     (socklen_t) args[2]);
+		case __NR_bind:		return (long) nxlibc_syscall_bind((int) args[0], 
+									  (const struct sockaddr *) args[1], 
+									  (socklen_t) args[2]);
+		case __NR_listen:	return (long) nxlibc_syscall_listen((int) args[0], (int) args[1]);
+		case __NR_accept:	return (long) nxlibc_syscall_accept((int) args[0], 
+									    (struct sockaddr *) args[1], 
+									    (socklen_t *) args[2]);
+		case __NR_getsockname:	return (long) nxlibc_syscall_getsockname((int) args[0], 
+										 (struct sockaddr *) args[1], 
+										 (socklen_t *) args[2]);
+		case __NR_setsockopt:	return (long) nxlibc_syscall_setsockopt((int) args[0], (int) args[1], 
+										(int) args[2], (const void *) args[3], 
+										(socklen_t) args[4]);
+
+		/* IO: socket read/write operations */
+
+		case __NR_send:		return (long) nxlibc_syscall_send((int) args[0], (const void *) args[1], 
+			    						  (size_t) args[2], (int) args[3]);
+		case __NR_recv:		return (long) nxlibc_syscall_recv((int) args[0], (void *) args[1], 
+			    						  (size_t) args[2], (int) args[3]);
+		case __NR_recvfrom:	return (long) nxlibc_syscall_recvfrom((int) args[0], (void *) args[1], 
+									      (size_t) args[2], (int) args[3], 
+							                      (struct sockaddr *) args[4], 
+									      (socklen_t *) args[5]);
+		case __NR_sendto:	return (long) nxlibc_syscall_sendto((int) args[0], (const void *) args[1], 
+								            (size_t) args[2], (int) args[3], 
+								            (const struct sockaddr *) args[4], 
+								            (socklen_t) args[5]);
+
+		/* IO: polling calls */
+
+		case __NR__newselect:
+		case __NR_select:	return (long) nxlibc_syscall_select((int) args[0], (fd_set *) args[1], 
+									    (fd_set *) args[2], (fd_set*) args[3],
+									    (struct timeval *) args[4]); 
+		case __NR_poll:		return (long) nxlibc_syscall_poll((struct pollfd *) args[0], 
+									  (nfds_t) args[1], (int) args[2]);
+
+				  return -1;
+
+		/**** skipped calls: warn and continue ********/
+
+		case __NR_setrlimit:
+
+				  skip_syscall(nr);
+
+		/**** all other calls: make noise and abort ********/
+		default 	: 
+				  abort_syscall(nr); 
+	}
+
+	/* not reached */
+	return -1;
+}
+
+/** most (all) libc callers use macros that bypass this call, 
+    but we still have to support it. */
+#define syscall(nr, ...) intercept_syscall(nr, -1, __VA_ARGS__)
+
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall.S uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall.S
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall.S	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall.S	2009-12-02 03:45:16.000000000 +0000
@@ -20,10 +20,12 @@
  * and things will just work.
  */
 
+/* NEXUS: modified to allow syscall interception */
+
 .text
-.global syscall
-.type   syscall,%function
-syscall:
+.global orig_syscall
+.type   orig_syscall,%function
+orig_syscall:
 	pushl %ebp
 	pushl %edi
 	pushl %esi
@@ -47,4 +49,4 @@
 	jae  __syscall_error
 	ret			/* Return to caller.  */
 
-.size syscall,.-syscall
+.size orig_syscall,.-orig_syscall
diff -Nur uClibc-0.9.30.1-orig/libc/unistd/sleep.c uClibc-0.9.30.1/libc/unistd/sleep.c
--- uClibc-0.9.30.1-orig/libc/unistd/sleep.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/unistd/sleep.c	2009-12-02 03:45:16.000000000 +0000
@@ -28,6 +28,8 @@
 libc_hidden_proto(sigaction)
 libc_hidden_proto(sigprocmask)
 
+extern unsigned int nxlibc_syscall_sleep(unsigned int seconds);
+
 /* version perusing nanosleep */
 #if defined __UCLIBC_HAS_REALTIME__
 //libc_hidden_proto(__sigaddset)
@@ -55,6 +57,9 @@
    behaviour for this syscall.  Therefore we have to emulate it here.  */
 unsigned int sleep (unsigned int seconds)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+    return nxlibc_syscall_sleep(seconds);
+#else
     struct timespec ts = { .tv_sec = (long int) seconds, .tv_nsec = 0 };
     sigset_t set, oset;
     unsigned int result;
@@ -115,6 +120,7 @@
 	result = (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
 
     return result;
+#endif
 }
 #endif
 #else /* __UCLIBC_HAS_REALTIME__ */
@@ -125,6 +131,9 @@
 }
 unsigned int sleep (unsigned int seconds)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+    return nxlibc_syscall_sleep(seconds);
+#else
     struct sigaction act, oact;
     sigset_t set, oset;
     unsigned int result, remaining;
@@ -167,6 +176,7 @@
     __set_errno(old_errno);
 
     return result > seconds ? 0 : seconds - result;
+#endif
 }
 #endif /* __UCLIBC_HAS_REALTIME__ */
 libc_hidden_def(sleep)
diff -Nur uClibc-0.9.30.1-orig/libc/unistd/usleep.c uClibc-0.9.30.1/libc/unistd/usleep.c
--- uClibc-0.9.30.1-orig/libc/unistd/usleep.c	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libc/unistd/usleep.c	2009-12-02 03:45:16.000000000 +0000
@@ -9,6 +9,15 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#ifndef DISABLE_NEXUS_CHANGES
+extern int nxlibc_syscall_usleep(__useconds_t usec);
+
+int usleep (__useconds_t usec)
+{
+    return nxlibc_syscall_usleep(usec);
+}
+
+#else
 #if defined __USE_BSD || defined __USE_POSIX98
 #if defined __UCLIBC_HAS_REALTIME__
 /*libc_hidden_proto(nanosleep) need the reloc for cancellation*/
@@ -33,3 +42,5 @@
 }
 #endif /* __UCLIBC_HAS_REALTIME__ */
 #endif
+#endif
+
diff -Nur uClibc-0.9.30.1-orig/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h uClibc-0.9.30.1/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h
--- uClibc-0.9.30.1-orig/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h	2009-12-02 03:45:16.000000000 +0000
@@ -60,13 +60,20 @@
 typedef long __pthread_cond_align_t;
 #endif
 
+//#include <nexus/sema.h>
 typedef struct
 {
+#if 0
   struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
   _pthread_descr __c_waiting;        /* Threads waiting on this condition */
   char __padding[48 - sizeof (struct _pthread_fastlock)
 		 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
   __pthread_cond_align_t __align;
+#else
+  //CondVar cond_var;
+  char __cond_var[48 - sizeof(__pthread_cond_align_t)]; // CondVar without polluting namespace
+  __pthread_cond_align_t __align;
+#endif
 } pthread_cond_t;
 
 
@@ -79,32 +86,43 @@
 /* Keys for thread-specific data */
 typedef unsigned int pthread_key_t;
 
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
+
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
 
 /* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
-/* (The layout is unnatural to maintain binary compatibility
-    with earlier releases of LinuxThreads.) */
 typedef struct
 {
+#if 0
+// For reference: the glibc definition and comments
+/* (The layout is unnatural to maintain binary compatibility
+    with earlier releases of LinuxThreads.) */
+
   int __m_reserved;               /* Reserved for future use */
   int __m_count;                  /* Depth of recursive locking */
   _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
   int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
   struct _pthread_fastlock __m_lock; /* Underlying fast lock */
+#endif
+  // N.B. No binary compatibility with glibc
+  struct { int val; char pad[48 - sizeof(int)]; } mutex; // Sema mutex; // do not pollute namespace
+  struct { int val; char pad[48 - sizeof(int)]; } lock; // Sema lock; // do not pollute namespace
+  pthread_mutexattr_t attr;
+  pthread_t owner;
+  int count;
 } pthread_mutex_t;
 
 
-/* Attribute for mutex.  */
-typedef struct
-{
-  int __mutexkind;
-} pthread_mutexattr_t;
-
-
 /* Once-only execution */
 typedef int pthread_once_t;
 
 
-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+#ifdef __USE_UNIX98
 /* Read-write locks.  */
 typedef struct _pthread_rwlock_t
 {
@@ -128,7 +146,7 @@
 
 #ifdef __USE_XOPEN2K
 /* POSIX spinlock data type.  */
-typedef __volatile__ int pthread_spinlock_t;
+typedef volatile int pthread_spinlock_t;
 
 /* POSIX barrier. */
 typedef struct {
@@ -146,7 +164,4 @@
 #endif
 
 
-/* Thread identifiers */
-typedef unsigned long int pthread_t;
-
 #endif	/* bits/pthreadtypes.h */
diff -Nur uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h
--- uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h	2009-12-02 03:45:16.000000000 +0000
@@ -22,6 +22,9 @@
 #define __need_schedparam
 #include <bits/sched.h>
 
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
+
 /* Fast locks (not abstract because mutexes and conditions aren't abstract). */
 struct _pthread_fastlock
 {
@@ -52,11 +55,21 @@
 } pthread_attr_t;
 
 
+#ifdef __GLIBC_HAVE_LONG_LONG
+__extension__ typedef long long __pthread_cond_align_t;
+#else
+typedef long __pthread_cond_align_t;
+#endif
+
 /* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
 typedef struct
 {
+  /* libc original */
   struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
   _pthread_descr __c_waiting;        /* Threads waiting on this condition */
+
+  /* nexus version */
+  void *condvar;
 } pthread_cond_t;
 
 
@@ -69,25 +82,29 @@
 /* Keys for thread-specific data */
 typedef unsigned int pthread_key_t;
 
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
 
 /* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
 /* (The layout is unnatural to maintain binary compatibility
     with earlier releases of LinuxThreads.) */
 typedef struct
 {
+
+  /* For compilation compatibility with uclibc: the legacy fields */
   int __m_reserved;               /* Reserved for future use */
   int __m_count;                  /* Depth of recursive locking */
   _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
   int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
   struct _pthread_fastlock __m_lock; /* Underlying fast lock */
-} pthread_mutex_t;
-
 
-/* Attribute for mutex.  */
-typedef struct
-{
-  int __mutexkind;
-} pthread_mutexattr_t;
+  /* Nexus fields: no compatibility with glibc */
+  void *sema;
+  pthread_t owner;
+} pthread_mutex_t;
 
 
 /* Once-only execution */
@@ -136,7 +153,4 @@
 #endif
 
 
-/* Thread identifiers */
-typedef unsigned long int pthread_t;
-
 #endif	/* bits/pthreadtypes.h */
diff -Nur uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h
--- uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h	2009-12-02 03:41:03.000000000 +0000
+++ uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h	2009-12-02 03:45:16.000000000 +0000
@@ -31,7 +31,7 @@
 /* Initializers.  */
 
 #define PTHREAD_MUTEX_INITIALIZER \
-  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
+  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER, NULL, 0}
 #ifdef __USE_GNU
 # define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
   {0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, __LOCK_INITIALIZER}
@@ -41,7 +41,7 @@
   {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
 #endif
 
-#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0}
+#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0, NULL}
 
 #if defined __USE_UNIX98 || defined __USE_XOPEN2K
 # define PTHREAD_RWLOCK_INITIALIZER \
