diff -Nur uClibc-0.9.30.1-orig/include/sys/syscall.h uClibc-0.9.30.1/include/sys/syscall.h
--- uClibc-0.9.30.1-orig/include/sys/syscall.h	2010-12-13 19:35:14.285264002 -0500
+++ uClibc-0.9.30.1/include/sys/syscall.h	2010-12-13 19:42:20.757264000 -0500
@@ -34,4 +34,26 @@
 # include <bits/syscalls.h>
 #endif
 
+/* Nexus: added direct socket system calls so that we do
+   not have to jump through yet another tunnel (socketcall()) 
+ 
+   Cannot add them to bits/sysnum.h, because that is autogenerated.
+   WARNING: this also means that with a different uclibc configuration
+            the numbering might change (?) Certainly, these numbers do
+	    not correspond with actual libc numbers.
+ */
+
+#define __NR_socket 253
+#define __NR_bind 254
+#define __NR_connect 255
+#define __NR_listen 256
+#define __NR_accept 257
+#define __NR_getsockname 258
+#define __NR_setsockopt 259
+
+#define __NR_send 260
+#define __NR_recv 261
+#define __NR_sendto 262
+#define __NR_recvfrom 263
+
 #endif
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/closedir.c uClibc-0.9.30.1/libc/misc/dirent/closedir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/closedir.c	2010-12-13 19:35:14.085264002 -0500
+++ uClibc-0.9.30.1/libc/misc/dirent/closedir.c	2010-12-13 19:42:20.757264000 -0500
@@ -13,8 +13,13 @@
 libc_hidden_proto(closedir)
 libc_hidden_proto(close)
 
+extern int nxlibc_syscall_closedir(DIR * dir);
+
 int closedir(DIR * dir)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_closedir(dir);
+#else
 	int fd;
 
 	if (!dir) {
@@ -34,5 +39,6 @@
 	free(dir->dd_buf);
 	free(dir);
 	return close(fd);
+#endif
 }
 libc_hidden_def(closedir)
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/opendir.c uClibc-0.9.30.1/libc/misc/dirent/opendir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/opendir.c	2010-12-13 19:35:14.085264002 -0500
+++ uClibc-0.9.30.1/libc/misc/dirent/opendir.c	2010-12-13 19:42:20.757264000 -0500
@@ -21,15 +21,21 @@
 libc_hidden_proto(stat)
 libc_hidden_proto(fstat)
 
+extern DIR *nxlibc_syscall_opendir(const char *name);
+
 /* opendir just makes an open() call - it return NULL if it fails
  * (open sets errno), otherwise it returns a DIR * pointer.
  */
 DIR *opendir(const char *name)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_opendir(name);
+#else
 	int fd;
 	struct stat statbuf;
 	DIR *ptr;
 
+
 #ifndef O_DIRECTORY
 	/* O_DIRECTORY is linux specific and has been around since like 2.1.x */
 	if (stat(name, &statbuf))
@@ -79,5 +85,6 @@
 	}
 	__pthread_mutex_init(&(ptr->dd_lock), NULL);
 	return ptr;
+#endif
 }
 libc_hidden_def(opendir)
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/readdir.c uClibc-0.9.30.1/libc/misc/dirent/readdir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/readdir.c	2010-12-13 19:35:14.085264002 -0500
+++ uClibc-0.9.30.1/libc/misc/dirent/readdir.c	2010-12-13 19:42:20.757264000 -0500
@@ -17,6 +17,9 @@
 
 struct dirent *readdir(DIR * dir)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_readdir(dir);
+#else
 	ssize_t bytes;
 	struct dirent *de;
 
@@ -53,5 +56,6 @@
 all_done:
 	__UCLIBC_MUTEX_UNLOCK(dir->dd_lock);
 	return de;
+#endif
 }
 libc_hidden_def(readdir)
diff -Nur uClibc-0.9.30.1-orig/libc/misc/dirent/rewinddir.c uClibc-0.9.30.1/libc/misc/dirent/rewinddir.c
--- uClibc-0.9.30.1-orig/libc/misc/dirent/rewinddir.c	2010-12-13 19:35:14.085264002 -0500
+++ uClibc-0.9.30.1/libc/misc/dirent/rewinddir.c	2010-12-13 19:42:20.757264000 -0500
@@ -11,9 +11,14 @@
 
 libc_hidden_proto(lseek)
 
+extern void nxlibc_syscall_rewinddir(DIR * dir);
+
 /* rewinddir() just does an lseek(fd,0,0) - see close for comments */
 void rewinddir(DIR * dir)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_rewinddir(dir);
+#else
 	if (!dir) {
 		__set_errno(EBADF);
 		return;
@@ -22,4 +27,5 @@
 	lseek(dir->dd_fd, 0, SEEK_SET);
 	dir->dd_nextoff = dir->dd_nextloc = dir->dd_size = 0;
 	__UCLIBC_MUTEX_UNLOCK(dir->dd_lock);
+#endif
 }
diff -Nur uClibc-0.9.30.1-orig/libc/stdlib/abort.c uClibc-0.9.30.1/libc/stdlib/abort.c
--- uClibc-0.9.30.1-orig/libc/stdlib/abort.c	2010-12-13 19:35:14.261264002 -0500
+++ uClibc-0.9.30.1/libc/stdlib/abort.c	2010-12-13 19:42:33.381264001 -0500
@@ -54,8 +54,15 @@
 /* Cause an abnormal program termination with core-dump */
 void abort(void)
 {
+	extern void Debug_Abort(unsigned long ebp);
 	sigset_t sigs;
 
+	{
+		unsigned long ebp;
+  		__asm__("movl %%ebp, %0" : "=g" (ebp));
+		Debug_Abort(ebp);
+	}
+
 	/* Make sure we acquire the lock before proceeding */
 	__UCLIBC_MUTEX_LOCK_CANCEL_UNSAFE(mylock);
 
diff -Nur uClibc-0.9.30.1-orig/libc/stdlib/malloc-standard/malloc.h uClibc-0.9.30.1/libc/stdlib/malloc-standard/malloc.h
--- uClibc-0.9.30.1-orig/libc/stdlib/malloc-standard/malloc.h	2010-12-13 19:35:14.265264002 -0500
+++ uClibc-0.9.30.1/libc/stdlib/malloc-standard/malloc.h	2010-12-13 19:42:20.757264000 -0500
@@ -122,7 +122,7 @@
    of kernel resources.
 */
 #ifndef MMAP_AS_MORECORE_SIZE
-#define MMAP_AS_MORECORE_SIZE (1024 * 1024)
+#define MMAP_AS_MORECORE_SIZE (1024 * 1024 * 1024) // XXX reset when mmap works
 #endif
 
 /*
@@ -322,7 +322,7 @@
 #define M_MMAP_THRESHOLD      -3
 
 #ifndef DEFAULT_MMAP_THRESHOLD
-#define DEFAULT_MMAP_THRESHOLD (256 * 1024)
+#define DEFAULT_MMAP_THRESHOLD (256 * 1024 * 4096) // XXX reset when mmap works
 #endif
 
 /*
diff -Nur uClibc-0.9.30.1-orig/libc/stdlib/setenv.c uClibc-0.9.30.1/libc/stdlib/setenv.c
--- uClibc-0.9.30.1-orig/libc/stdlib/setenv.c	2010-12-13 19:35:14.269264002 -0500
+++ uClibc-0.9.30.1/libc/stdlib/setenv.c	2010-12-13 19:42:20.761264000 -0500
@@ -154,6 +154,8 @@
     len = strlen (name);
     __UCLIBC_MUTEX_LOCK(mylock);
     ep = __environ;
+    if (ep == NULL) /* No environment: cannot be set */
+		return 0;
     while (*ep != NULL) {
 		if (!strncmp (*ep, name, len) && (*ep)[len] == '=') {
 			/* Found it.  Remove this pointer by moving later ones back.  */
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/llseek.c uClibc-0.9.30.1/libc/sysdeps/linux/common/llseek.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/llseek.c	2010-12-13 19:35:14.137264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/llseek.c	2010-12-13 19:42:20.761264000 -0500
@@ -22,11 +22,17 @@
 		off_t, offset_lo, loff_t *, result, int, whence)
 # endif
 
+extern int nxlibc_syscall_lseek64(int fildes, int offset, int whence);
+
 loff_t __libc_lseek64(int fd, loff_t offset, int whence)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	return nxlibc_syscall_lseek64(fd, offset, whence);
+#else
 	loff_t result;
 	return(loff_t)(INLINE_SYSCALL (_llseek, 5, fd, (off_t) (offset >> 32),
 				(off_t) (offset & 0xffffffff), &result, whence) ?: result);
+#endif
 }
 #else
 extern __typeof(lseek) __libc_lseek;
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/mount.c uClibc-0.9.30.1/libc/sysdeps/linux/common/mount.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/mount.c	2010-12-13 19:35:14.133264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/mount.c	2010-12-13 19:42:20.761264000 -0500
@@ -9,6 +9,18 @@
 
 #include <sys/syscall.h>
 #include <sys/mount.h>
+
+#ifndef DISABLE_NEXUS_CHANGES
+int mount(const char *source, const char *target,
+	  const char *filesystemtype, unsigned long mountflags,
+	  const void *data)
+{
+	return nxlibc_syscall_mount(source, target, filesystemtype,
+				    mountflags, data);
+}
+
+#else
 _syscall5(int, mount, const char *, specialfile, const char *, dir,
 		  const char *, filesystemtype, unsigned long, rwflag,
 		  const void *, data)
+#endif
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/munmap.c uClibc-0.9.30.1/libc/sysdeps/linux/common/munmap.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/munmap.c	2010-12-13 19:35:14.129264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/munmap.c	2010-12-13 19:42:20.761264000 -0500
@@ -11,7 +11,13 @@
 #include <unistd.h>
 #include <sys/mman.h>
 
+#include "linuxcalls_io.h"
+
 libc_hidden_proto(munmap)
 
-_syscall2(int, munmap, void *, start, size_t, length)
+int munmap(void *start, size_t length)
+{
+	return nxlibc_syscall_munmap(start, length);
+}
+
 libc_hidden_def(munmap)
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/open64.c uClibc-0.9.30.1/libc/sysdeps/linux/common/open64.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/open64.c	2010-12-13 19:35:14.125264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/open64.c	2010-12-13 19:42:20.761264000 -0500
@@ -18,11 +18,17 @@
 extern __typeof(open) __libc_open;
 libc_hidden_proto(__libc_open)
 
+extern int nxlibc_syscall_open64(const char *file, int oflag);
+
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
    a third argument is the file protection.  */
 libc_hidden_proto(__libc_open64)
 int __libc_open64 (const char *file, int oflag, ...)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+	// XXX Nexus open64 does not support ellipsis (...)
+	return nxlibc_syscall_open64(file, oflag);
+#else
     mode_t mode = 0;
 
     if (oflag & O_CREAT)
@@ -34,6 +40,7 @@
     }
 
     return __libc_open(file, oflag | O_LARGEFILE, mode);
+#endif
 }
 libc_hidden_def(__libc_open64)
 
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/sync.c uClibc-0.9.30.1/libc/sysdeps/linux/common/sync.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/sync.c	2010-12-13 19:35:14.133264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/sync.c	2010-12-13 19:42:20.761264000 -0500
@@ -20,6 +20,6 @@
 
 void sync(void)
 {
-	INLINE_SYSCALL(sync, 0);
+	_touchup_errno(intercept_syscall(__NR_sync, 0));
 }
 #endif
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/umount.c uClibc-0.9.30.1/libc/sysdeps/linux/common/umount.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/common/umount.c	2010-12-13 19:35:14.129264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/common/umount.c	2010-12-13 19:42:20.761264000 -0500
@@ -12,6 +12,16 @@
 #if defined __USE_GNU
 #include <sys/mount.h>
 
+#ifndef DISABLE_NEXUS_CHANGES
+#include <stdio.h>
+int umount(const char *special_file)
+{
+	fprintf(stderr, "umount: not implemented\n");
+	errno = -EBUSY;
+	return -1;
+}
+#else
+
 /* arch provides umount() syscall */
 #ifdef __NR_umount
 
@@ -39,3 +49,4 @@
 
 #endif
 #endif
+#endif
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/kernel_stat.h uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/kernel_stat.h
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/kernel_stat.h	2010-12-13 19:35:14.189264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/kernel_stat.h	2010-12-13 19:42:20.761264000 -0500
@@ -9,6 +9,7 @@
  * struct stat should look like...  It turns out each arch has a
  * different opinion on the subject... */
 
+#if 0
 struct kernel_stat {
 	unsigned short st_dev;
 	unsigned short __pad1;
@@ -55,6 +56,14 @@
 	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
 	unsigned long long	st_ino;
 };
+#else
+
+// Nexus uses libc stat structures
+
+#define kernel_stat stat
+#define kernel_stat64 stat64
+
+#endif
 
 #endif	/*  _BITS_STAT_STRUCT_H */
 
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/syscalls.h uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/syscalls.h
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/bits/syscalls.h	2010-12-13 19:35:14.189264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/bits/syscalls.h	2010-12-13 19:42:20.761264000 -0500
@@ -102,11 +102,14 @@
      ".endm\n\t");
 #endif
 
+/* Nexus patch: for some reason we have to avoid using
+   variadic macros in case they expand to zero. */
+
 #undef _syscall0
 #define _syscall0(type,name) \
 type name(void) \
 { \
-return (type) (INLINE_SYSCALL(name, 0)); \
+return (type) (_touchup_errno(intercept_syscall(__NR_##name, 0))); \
 }
 
 #undef _syscall1
@@ -152,60 +155,22 @@
 { \
 return (type) (INLINE_SYSCALL(name, 6, arg1, arg2, arg3, arg4, arg5, arg6)); \
 }
- #define INLINE_SYSCALL(name, nr, args...) \
-  ({                                                                          \
-    unsigned int _resultvar = INTERNAL_SYSCALL (name, , nr, args);            \
-    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (_resultvar, ), 0))        \
-      {                                                                       \
-        __set_errno (INTERNAL_SYSCALL_ERRNO (_resultvar, ));                  \
-        _resultvar = 0xffffffff;                                              \
-      }                                                                       \
-    (int) _resultvar; })
-
-#define INTERNAL_SYSCALL(name, err, nr, args...) \
-  ({                                                                          \
-    register unsigned int resultvar;                                          \
-    __asm__ __volatile__ (                                                            \
-    LOADARGS_##nr                                                             \
-    "movl %1, %%eax\n\t"                                                      \
-    "int $0x80\n\t"                                                           \
-    RESTOREARGS_##nr                                                          \
-    : "=a" (resultvar)                                                        \
-    : "i" (__NR_##name) ASMFMT_##nr(args) : "memory", "cc");                  \
-     (int) resultvar; })
-
-#define LOADARGS_0
-#define LOADARGS_1 \
-    "bpushl .L__X'%k2, %k2\n\t"						      \
-    "bmovl .L__X'%k2, %k2\n\t"
-#define LOADARGS_2	LOADARGS_1
-#define LOADARGS_3	LOADARGS_1
-#define LOADARGS_4	LOADARGS_1
-#define LOADARGS_5	LOADARGS_1
-#define LOADARGS_6	LOADARGS_1 "push %%ebp ; movl %7, %%ebp\n\t"
-
-#define RESTOREARGS_0
-#define RESTOREARGS_1 \
-    "bpopl .L__X'%k2, %k2\n\t"
-#define RESTOREARGS_2	RESTOREARGS_1
-#define RESTOREARGS_3	RESTOREARGS_1
-#define RESTOREARGS_4	RESTOREARGS_1
-#define RESTOREARGS_5	RESTOREARGS_1
-#define RESTOREARGS_6	"pop %%ebp\n\t" RESTOREARGS_1
-
-#define ASMFMT_0()
-#define ASMFMT_1(arg1) \
-	, "acdSD" (arg1)
-#define ASMFMT_2(arg1, arg2) \
-	, "adSD" (arg1), "c" (arg2)
-#define ASMFMT_3(arg1, arg2, arg3) \
-	, "aSD" (arg1), "c" (arg2), "d" (arg3)
-#define ASMFMT_4(arg1, arg2, arg3, arg4) \
-	, "aD" (arg1), "c" (arg2), "d" (arg3), "S" (arg4)
-#define ASMFMT_5(arg1, arg2, arg3, arg4, arg5) \
-	, "a" (arg1), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5)
-#define ASMFMT_6(arg1, arg2, arg3, arg4, arg5, arg6) \
-	, "a" (arg1), "c" (arg2), "d" (arg3), "S" (arg4), "D" (arg5), "m" (arg6)
 
+long int intercept_syscall (long int nr, int argcount, ...);
+
+/** check system call result and update errno accordingly */
+static inline long int _touchup_errno(int ret)
+{
+	if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (ret, ), 0)) {
+		__set_errno (INTERNAL_SYSCALL_ERRNO (ret, ));
+		ret = 0xffffffff;                            
+	}
+	return ret;
+}
+
+#define INLINE_SYSCALL(name, nr, ...) 					\
+	 _touchup_errno(intercept_syscall(__NR_##name, nr, __VA_ARGS__))
+	 
 #endif /* __ASSEMBLER__ */
 #endif /* _BITS_SYSCALLS_H */
+
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/brk.c uClibc-0.9.30.1/libc/sysdeps/linux/i386/brk.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/brk.c	2010-12-13 19:35:14.185264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/brk.c	2010-12-13 19:42:20.761264000 -0500
@@ -27,8 +27,12 @@
 libc_hidden_proto(brk)
 int brk (void *addr)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+    return INLINE_SYSCALL(brk, 1, addr);
+#else
     void *__unbounded newbrk, *__unbounded scratch;
 
+
     __asm__ ("movl %%ebx, %1\n"	/* Save %ebx in scratch register.  */
 	    "movl %3, %%ebx\n"	/* Put ADDR in %ebx to be syscall arg.  */
 	    "int $0x80 # %2\n"	/* Perform the system call.  */
@@ -45,5 +49,6 @@
     }
 
     return 0;
+#endif
 }
 libc_hidden_def(brk)
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/Makefile.arch uClibc-0.9.30.1/libc/sysdeps/linux/i386/Makefile.arch
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/Makefile.arch	2010-12-13 19:35:14.189264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/Makefile.arch	2010-12-13 19:42:20.761264000 -0500
@@ -5,10 +5,10 @@
 # Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
 #
 
-CSRC := brk.c sigaction.c __syscall_error.c
+CSRC := brk.c sigaction.c __syscall_error.c syscall_intercept.c mmap.c
 
 SSRC := \
 	__longjmp.S vfork.S clone.S setjmp.S bsd-setjmp.S bsd-_setjmp.S \
-	sync_file_range.S syscall.S mmap.S mmap64.S posix_fadvise64.S
+	sync_file_range.S syscall.S mmap64.S posix_fadvise64.S
 
 include $(top_srcdir)libc/sysdeps/linux/Makefile.commonarch
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/mmap.c uClibc-0.9.30.1/libc/sysdeps/linux/i386/mmap.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/mmap.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/mmap.c	2010-12-13 19:42:20.761264000 -0500
@@ -0,0 +1,18 @@
+/** NexusOS version of mmap */
+
+#include "linuxcalls_io.h"
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot,
+	     int flags, int fd, __off_t offset)
+{
+	return nxlibc_syscall_mmap(addr, len, prot, flags, fd, offset);
+}
+
+// used internally
+__ptr_t __GI_mmap(__ptr_t addr, size_t len, int prot,
+	          int flags, int fd, __off_t offset) 
+{
+	return nxlibc_syscall_mmap(addr, len, prot, flags, fd, offset);
+}
+
+
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall_intercept.c uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall_intercept.c
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall_intercept.c	1969-12-31 19:00:00.000000000 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall_intercept.c	2010-12-13 19:42:20.761264000 -0500
@@ -0,0 +1,32 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <sys/syscall.h>
+
+
+extern long int nxlibc_intercept_syscall(long int nr, int argc, va_list args);
+
+/** Intercept system calls and redirect them to the nexus libraries.
+    
+    @param argcount is the number of used arguments or -1 if unknown
+    @return is return of the call if taken, -1 if skipped and
+    the function does not return on aborted calls. */
+long int 
+intercept_syscall (long int nr, int argcount, ...)
+{
+	long int ret;
+	va_list arglist;
+
+	/* fetch args */
+	va_start(arglist, argcount);
+	ret = nxlibc_intercept_syscall(nr, argcount, arglist);
+	va_end(arglist);
+
+	return ret;
+}
+
+/** most (all) libc callers use macros that bypass this call, 
+    but we still have to support it. */
+#define syscall(nr, ...) intercept_syscall(nr, -1, __VA_ARGS__)
+
diff -Nur uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall.S uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall.S
--- uClibc-0.9.30.1-orig/libc/sysdeps/linux/i386/syscall.S	2010-12-13 19:35:14.185264002 -0500
+++ uClibc-0.9.30.1/libc/sysdeps/linux/i386/syscall.S	2010-12-13 19:42:20.761264000 -0500
@@ -20,10 +20,12 @@
  * and things will just work.
  */
 
+/* NEXUS: modified to allow syscall interception */
+
 .text
-.global syscall
-.type   syscall,%function
-syscall:
+.global orig_syscall
+.type   orig_syscall,%function
+orig_syscall:
 	pushl %ebp
 	pushl %edi
 	pushl %esi
@@ -47,4 +49,4 @@
 	jae  __syscall_error
 	ret			/* Return to caller.  */
 
-.size syscall,.-syscall
+.size orig_syscall,.-orig_syscall
diff -Nur uClibc-0.9.30.1-orig/libc/unistd/sleep.c uClibc-0.9.30.1/libc/unistd/sleep.c
--- uClibc-0.9.30.1-orig/libc/unistd/sleep.c	2010-12-13 19:35:14.237264002 -0500
+++ uClibc-0.9.30.1/libc/unistd/sleep.c	2010-12-13 19:42:20.761264000 -0500
@@ -28,6 +28,8 @@
 libc_hidden_proto(sigaction)
 libc_hidden_proto(sigprocmask)
 
+extern unsigned int nxlibc_syscall_sleep(unsigned int seconds);
+
 /* version perusing nanosleep */
 #if defined __UCLIBC_HAS_REALTIME__
 //libc_hidden_proto(__sigaddset)
@@ -55,6 +57,9 @@
    behaviour for this syscall.  Therefore we have to emulate it here.  */
 unsigned int sleep (unsigned int seconds)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+    return nxlibc_syscall_sleep(seconds);
+#else
     struct timespec ts = { .tv_sec = (long int) seconds, .tv_nsec = 0 };
     sigset_t set, oset;
     unsigned int result;
@@ -115,6 +120,7 @@
 	result = (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
 
     return result;
+#endif
 }
 #endif
 #else /* __UCLIBC_HAS_REALTIME__ */
@@ -125,6 +131,9 @@
 }
 unsigned int sleep (unsigned int seconds)
 {
+#ifndef DISABLE_NEXUS_CHANGES
+    return nxlibc_syscall_sleep(seconds);
+#else
     struct sigaction act, oact;
     sigset_t set, oset;
     unsigned int result, remaining;
@@ -167,6 +176,7 @@
     __set_errno(old_errno);
 
     return result > seconds ? 0 : seconds - result;
+#endif
 }
 #endif /* __UCLIBC_HAS_REALTIME__ */
 libc_hidden_def(sleep)
diff -Nur uClibc-0.9.30.1-orig/libc/unistd/usleep.c uClibc-0.9.30.1/libc/unistd/usleep.c
--- uClibc-0.9.30.1-orig/libc/unistd/usleep.c	2010-12-13 19:35:14.237264002 -0500
+++ uClibc-0.9.30.1/libc/unistd/usleep.c	2010-12-13 19:42:20.761264000 -0500
@@ -9,6 +9,15 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#ifndef DISABLE_NEXUS_CHANGES
+extern int nxlibc_syscall_usleep(__useconds_t usec);
+
+int usleep (__useconds_t usec)
+{
+    return nxlibc_syscall_usleep(usec);
+}
+
+#else
 #if defined __USE_BSD || defined __USE_POSIX98
 #if defined __UCLIBC_HAS_REALTIME__
 /*libc_hidden_proto(nanosleep) need the reloc for cancellation*/
@@ -33,3 +42,5 @@
 }
 #endif /* __UCLIBC_HAS_REALTIME__ */
 #endif
+#endif
+
diff -Nur uClibc-0.9.30.1-orig/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h uClibc-0.9.30.1/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h
--- uClibc-0.9.30.1-orig/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h	2010-12-13 19:35:14.309264002 -0500
+++ uClibc-0.9.30.1/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h	2010-12-13 19:42:20.765264000 -0500
@@ -60,13 +60,20 @@
 typedef long __pthread_cond_align_t;
 #endif
 
+//#include <nexus/sema.h>
 typedef struct
 {
+#if 0
   struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
   _pthread_descr __c_waiting;        /* Threads waiting on this condition */
   char __padding[48 - sizeof (struct _pthread_fastlock)
 		 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
   __pthread_cond_align_t __align;
+#else
+  //CondVar cond_var;
+  char __cond_var[48 - sizeof(__pthread_cond_align_t)]; // CondVar without polluting namespace
+  __pthread_cond_align_t __align;
+#endif
 } pthread_cond_t;
 
 
@@ -79,32 +86,43 @@
 /* Keys for thread-specific data */
 typedef unsigned int pthread_key_t;
 
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
+
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
 
 /* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
-/* (The layout is unnatural to maintain binary compatibility
-    with earlier releases of LinuxThreads.) */
 typedef struct
 {
+#if 0
+// For reference: the glibc definition and comments
+/* (The layout is unnatural to maintain binary compatibility
+    with earlier releases of LinuxThreads.) */
+
   int __m_reserved;               /* Reserved for future use */
   int __m_count;                  /* Depth of recursive locking */
   _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
   int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
   struct _pthread_fastlock __m_lock; /* Underlying fast lock */
+#endif
+  // N.B. No binary compatibility with glibc
+  struct { int val; char pad[48 - sizeof(int)]; } mutex; // Sema mutex; // do not pollute namespace
+  struct { int val; char pad[48 - sizeof(int)]; } lock; // Sema lock; // do not pollute namespace
+  pthread_mutexattr_t attr;
+  pthread_t owner;
+  int count;
 } pthread_mutex_t;
 
 
-/* Attribute for mutex.  */
-typedef struct
-{
-  int __mutexkind;
-} pthread_mutexattr_t;
-
-
 /* Once-only execution */
 typedef int pthread_once_t;
 
 
-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+#ifdef __USE_UNIX98
 /* Read-write locks.  */
 typedef struct _pthread_rwlock_t
 {
@@ -128,7 +146,7 @@
 
 #ifdef __USE_XOPEN2K
 /* POSIX spinlock data type.  */
-typedef __volatile__ int pthread_spinlock_t;
+typedef volatile int pthread_spinlock_t;
 
 /* POSIX barrier. */
 typedef struct {
@@ -146,7 +164,4 @@
 #endif
 
 
-/* Thread identifiers */
-typedef unsigned long int pthread_t;
-
 #endif	/* bits/pthreadtypes.h */
diff -Nur uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h
--- uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h	2010-12-13 19:35:14.321264002 -0500
+++ uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h	2010-12-13 19:42:20.765264000 -0500
@@ -22,6 +22,9 @@
 #define __need_schedparam
 #include <bits/sched.h>
 
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
+
 /* Fast locks (not abstract because mutexes and conditions aren't abstract). */
 struct _pthread_fastlock
 {
@@ -52,11 +55,21 @@
 } pthread_attr_t;
 
 
+#ifdef __GLIBC_HAVE_LONG_LONG
+__extension__ typedef long long __pthread_cond_align_t;
+#else
+typedef long __pthread_cond_align_t;
+#endif
+
 /* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
 typedef struct
 {
+  /* libc original */
   struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
   _pthread_descr __c_waiting;        /* Threads waiting on this condition */
+
+  /* nexus version */
+  void *condvar;
 } pthread_cond_t;
 
 
@@ -69,25 +82,29 @@
 /* Keys for thread-specific data */
 typedef unsigned int pthread_key_t;
 
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
 
 /* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
 /* (The layout is unnatural to maintain binary compatibility
     with earlier releases of LinuxThreads.) */
 typedef struct
 {
+
+  /* For compilation compatibility with uclibc: the legacy fields */
   int __m_reserved;               /* Reserved for future use */
   int __m_count;                  /* Depth of recursive locking */
   _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
   int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
   struct _pthread_fastlock __m_lock; /* Underlying fast lock */
-} pthread_mutex_t;
-
 
-/* Attribute for mutex.  */
-typedef struct
-{
-  int __mutexkind;
-} pthread_mutexattr_t;
+  /* Nexus fields: no compatibility with glibc */
+  void *sema;
+  pthread_t owner;
+} pthread_mutex_t;
 
 
 /* Once-only execution */
@@ -136,7 +153,4 @@
 #endif
 
 
-/* Thread identifiers */
-typedef unsigned long int pthread_t;
-
 #endif	/* bits/pthreadtypes.h */
diff -Nur uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h
--- uClibc-0.9.30.1-orig/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h	2010-12-13 19:35:14.321264002 -0500
+++ uClibc-0.9.30.1/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h	2010-12-13 19:42:20.765264000 -0500
@@ -31,7 +31,7 @@
 /* Initializers.  */
 
 #define PTHREAD_MUTEX_INITIALIZER \
-  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
+  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER, NULL, 0}
 #ifdef __USE_GNU
 # define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
   {0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, __LOCK_INITIALIZER}
@@ -41,7 +41,7 @@
   {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
 #endif
 
-#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0}
+#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0, NULL}
 
 #if defined __USE_UNIX98 || defined __USE_XOPEN2K
 # define PTHREAD_RWLOCK_INITIALIZER \
