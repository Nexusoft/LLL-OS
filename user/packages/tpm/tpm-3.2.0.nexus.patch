diff -Nur tpm-3.2.0-orig/libtpm/dirs.c tpm-3.2.0/libtpm/dirs.c
--- tpm-3.2.0-orig/libtpm/dirs.c	1970-01-01 00:00:00.000000000 +0000
+++ tpm-3.2.0/libtpm/dirs.c	2010-04-10 21:39:07.000000000 +0000
@@ -0,0 +1,102 @@
+#include <stdint.h>
+#include <stdio.h>
+
+#include <tpm.h>
+#include <tpmutil.h>
+#include <hmac.h>
+#include <oiaposap.h>
+
+unsigned char dirdata[TPM_MAX_BUFF_SIZE]; /* request/response buffer */
+
+uint32_t TPM_DirRead(int i, unsigned char *databuf, int datalen){
+  unsigned char dir_fmt[] = "00 c1 T l l";
+  uint32_t ret;
+  int ordinal, dirindex;
+
+  if(datalen != TPM_HASH_SIZE + TPM_DATA_OFFSET){
+    printf("Incorrect size of buffer for TPM_DirRead\n");
+    return -1;
+  }
+
+  dirindex = htonl(i);
+      
+  ordinal = htonl(26);
+  ret = TSS_buildbuff(dir_fmt, databuf, ordinal, dirindex);
+  if (ret < 0)
+    return -1;
+  ret = TPM_Transmit(databuf, "DirRead");
+
+#if 1
+  {
+	  int j;
+
+  	printf("NXDEBUG: DIR=\n");
+  	for(j = 10; j < 30; j++)
+  	  printf("0x%02x ", databuf[j]);
+  	printf("\n");
+  }
+#endif
+
+  return 0;
+}
+
+/*
+ * index = index of DIR to write to 
+ * value = value to place in DIR
+ * ohash = hash of owner's password
+ */
+uint32_t TPM_DirWriteAuth(int index, unsigned char *value, unsigned char *ohash){
+  unsigned char dir_fmt[] = "00 c2 T l l % l % o %";
+  unsigned char c;
+  unsigned int authhandle, ret;
+  int ordinal, dirindex;
+  unsigned char oddnonce[TPM_NONCE_SIZE];
+  unsigned char evennonce[TPM_NONCE_SIZE];
+  unsigned char pubauth[TPM_HASH_SIZE];
+
+  ordinal = htonl(25);
+  dirindex = htonl(index);
+
+  /* generate odd nonce */
+  if (TSS_gennonce(oddnonce) == 0) {
+  	fprintf(stderr, "%s: insufficient entropy\n", __FUNCTION__);
+	return -1;
+  }
+  /* Open OIAP ssion */
+  ret = TSS_OIAPopen(&authhandle, evennonce);
+
+  if (ret != 0)
+    return -1;
+
+  /* move Network byte order data to variables for hmac calculation */
+  ordinal = htonl(25);
+  dirindex = htonl(index);
+  c = 0;
+
+  /* calculate authorization HMAC value */
+  ret = TSS_authhmac(pubauth, ohash, TPM_HASH_SIZE, evennonce, oddnonce, c, TPM_U32_SIZE, &ordinal, 4, &dirindex, TPM_HASH_SIZE, value, 0, 0);
+
+  if (ret < 0) {
+    TSS_HANDclose(authhandle);
+    return -1;
+  }
+  
+  /* build the request buffer */
+  ret = TSS_buildbuff(dir_fmt, dirdata,
+		  ordinal,
+		  dirindex,
+		  TPM_HASH_SIZE, value,
+		  htonl(authhandle),
+		  TPM_NONCE_SIZE, oddnonce, 
+		  c, 
+		  TPM_HASH_SIZE, pubauth);
+  
+  if (ret <= 0) {
+    TSS_HANDclose(authhandle);
+    return -1;
+  }
+  
+  ret = TPM_Transmit(dirdata, "DirWriteAuth");
+  return ret;
+}
+
diff -Nur tpm-3.2.0-orig/libtpm/Makefile tpm-3.2.0/libtpm/Makefile
--- tpm-3.2.0-orig/libtpm/Makefile	2010-04-10 21:38:55.000000000 +0000
+++ tpm-3.2.0/libtpm/Makefile	2010-04-10 21:40:39.000000000 +0000
@@ -2,8 +2,8 @@
 
 LIBRARIES = libtpm.a
 HEADERS = tpmfunc.h tpm.h tpmkeys.h
-SOURCES = bind.c hmac.c keys.c migrate.c miscfunc.c oiaposap.c owner.c pcrs.c seal.c signature.c tpmutil.c chgauth.c
-OBJECTS = bind.o hmac.o keys.o migrate.o miscfunc.o oiaposap.o owner.o pcrs.o seal.o signature.o tpmutil.o chgauth.o
+SOURCES = bind.c dirs.c hmac.c keys.c migrate.c miscfunc.c oiaposap.c owner.c pcrs.c seal.c signature.c tpmutil.c chgauth.c
+OBJECTS = bind.o dirs.o hmac.o keys.o migrate.o miscfunc.o oiaposap.o owner.o pcrs.o seal.o signature.o tpmutil.o chgauth.o
 EXTRA_DIST = hmac.h oiaposap.h pcrs.h tpmutil.h ./linux
 
 libtpm.a: $(OBJECTS)
diff -Nur tpm-3.2.0-orig/libtpm/tpmfunc.h tpm-3.2.0/libtpm/tpmfunc.h
--- tpm-3.2.0-orig/libtpm/tpmfunc.h	2010-04-10 21:38:55.000000000 +0000
+++ tpm-3.2.0/libtpm/tpmfunc.h	2010-04-11 10:18:06.000000000 +0000
@@ -101,8 +101,10 @@
 				  unsigned int keyblen,
 				  unsigned char *encblob,
 				  unsigned int *encblen);
-uint32_t TPM_Reset();
+uint32_t TPM_Reset(void);
 uint32_t TPM_GetRandom(unsigned char *buf);
+uint32_t TPM_DirRead(int i, unsigned char *databuf, int datalen);
+uint32_t TPM_DirWriteAuth(int index, unsigned char *value, unsigned char *ohash);
 
 /* TPM helper functions */
 uint32_t TPM_SealCurrPCR(uint32_t keyhandle,
