#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <nexus/IPC.interface.h>
#include <nexus/LabelStore.interface.h>
#include <nexus/der.h>
#include <nexus/guard.h>
#include <nexus/namespace.h>
#include <nexus/debug.h>
#include <pthread.h>

#include "Keyboard_CounterRM.interface.h"
#include "Keyboard_Counter.interpose.h"
#include "InterposeEventDriver.interface.h"

#include "keyboardrm.h"

#define NUM_IPC_THREADS (4)
static pthread_t ipc_threads[NUM_IPC_THREADS];
static pthread_t accept_threads[NUM_IPC_THREADS];


#define NUM_RM_THREADS (4)
static pthread_t rm_threads[NUM_RM_THREADS];

static void *processing_loop_rm(void *ctx) { while(1) InterposeEventDriver_processNextCommand(); }
static void *processing_loop_ipc(void *ctx) { while(1) Keyboard_CounterRM_processNextCommand(); }
static void *accept_loop(void *ctx) { while(1) IDL_BINDACCEPT(Keyboard_CounterRM); }

char *target_name;
FSID store;
FSID hashcred_id;
SignedFormula *hashcred;
int wrap_target;

int main(int argc, char **argv) {
  int i;
 global_debug_level = DEBUG_LEVEL_INFO;
 printf("keyboardrm\n");
  if(argc < 2) {
    printf("KeyboardRM requires at least one argument (ipd_id to wrap)\n");
    exit(-1);
  }

  wrap_target = atoi(argv[1]);
  printf("Wrapping %d (%s)\n", wrap_target, argv[1]);

  Keyboard_CounterRM_serverInit();
  extern void Keyboard_Counter_serverInit(void); // this should be auto-generated by IDL in *.interpose.h, but isn't
  InterposeEventDriver_serverInit(); // must be first (initializes all_input)
  Keyboard_Counter_serverInit(); // must be second (uses all_input)

  int wrap_handle = IPC_Wrap(wrap_target);
  if(wrap_handle <= 0) {
    printf("invalid wrap channel %d!\n", wrap_handle);
    exit(-1);
  }
  printf("wrap channel = %d\n", wrap_handle);

  InterposeEventDriver_setServerTarget(wrap_handle);

  // get the name of the wrapped ipd
  printf("Getting name for ipd %d...\n", wrap_target);

  // XXX Poll
  unsigned char buf[4000];
  for(i=0 ;; i++) {
    sleep(2);
    int len = LabelStore_Get_IPD_Name(wrap_target, buf, sizeof(buf), NULL);
    if(len > 0) {
      printf("done: got %d bytes\n", len);
      break;
    }
    if (i > 5) {
      printf("error %d\n", len);
      exit(1);
    } else {
      printf("trying again\n");
    }
  }

  Form *target = form_from_der((Formula *)buf);
  if (!target) { printf("error\n"); exit(1); }
  char *target_namestr = form_to_pretty(target, 0);
  printf("target_name = %s\n", target_namestr);
  target_name = malloc(der_msglen(buf));
  memcpy(target_name, buf, der_msglen(buf));

  // create labelstore
  printf("Creating public_labels Label Store ... ");
  store = LabelStore_Store_Create("public_labels");
  if (!FSID_isValid(store)) { printf("error\n"); exit(1); }
  printf("done\n");

  // ask nexus to label us with our own hash
  printf("Asking for a label from nexus...\n");
  hashcred_id = LabelStore_Nexus_Label(store, 1, "hashcred", NULL, NULL);
  if (!FSID_isValid(hashcred_id)) { printf("error\n"); exit(1); }

  for(i=0; i < NUM_RM_THREADS; i++) {
    if(pthread_create(&rm_threads[i], NULL, processing_loop_rm, (void *) i)) {
      printf("could not fork rm processing thread %d\n", i);
    }
  }

  for(i=0; i < NUM_IPC_THREADS - 1; i++) {
    if(pthread_create(&ipc_threads[i], NULL, processing_loop_ipc, (void *) i)) {
      printf("could not fork ipc processing thread %d\n", i);
    }
    if(pthread_create(&accept_threads[i], NULL, accept_loop, NULL)) {
      printf("could not fork accept thread %d\n", i);
    }

  }

  printf("Initialization done\n");
  // this one also becomes a processing thread
  processing_loop_ipc((void*)i);
  return 0;
}


